<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>overview</title>
	</head>
<body>
<h1>overview</h1>

<hr />

<h2>语言处理器</h2>

<figure><img src="/Users/xerxes/note/compile/src/%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F.png"/></figure>

<h3>编译器</h3>

<p>程序运行之前需要先被翻译成计算机能够执行的形式，完成翻译工作的软件系统称为<strong>编译器</strong>。</p>

<p>简单来说，一个编译器就是一个程序，它可以阅读以某一种语言编写的程序，并把该程序翻译成一个等价的、用另一种语言编写的程序。编译器的重要任务之一是报告它在翻译过程中发现的源程序中的错误。</p>

<h3>解释器</h3>

<p><strong>解释器</strong>是另一种常见的语言处理器。它不通过翻译的方式生成目标程序。从用户角度来看，解释器直接利用用户提供的输入执行源程序中指定的操作。</p>

<p>在把用户输入映射称为输出的过程中，由一个编译器产生的机器语言目标程序通常比一个解释器快得多。然而解释器的错误诊断效果通常比编译器更好，因为它逐条语句执行源程序。</p>

<p>以Java 为例，Java 语言处理器结合了编译和解释过程。一个Java 源程序首先被编译成字节码，然后由Java 虚拟机对字节码解释执行。为了更快执行，有些被称为即使（just-in-time）编译器的Java 编译器在运行中间程序处理输入的前一刻首先把字节码翻译成机器语言，然后再执行程序。</p>

<h3>预处理器</h3>

<p>一个源程序可能被分割成多个模块，并存放于独立的文件中。把源程序聚合在一起的任务有时会由一个被称为<strong>预处理器</strong>的程序独立完成。预处理器还负责把那些称为宏的缩写形式转换为源语言的语句。</p>

<h3>汇编器</h3>

<p>经过预处理器的源程序作为输入传递给一个编译器，编译器可能产生一个汇编语言程序作为其输出，因为汇编语言比较容易输出和调试。</p>

<p>接着这个汇编语言程序由<strong>汇编器</strong>进行处理，并生成可重定位的机器代码。</p>

<h3>链接器/加载器</h3>

<p>大型程序经常被分成多个部分进行编译，因此可重定位的机器代码有必要和其他可重定位的目标文件以及库文件连接到一起，形成真正在机器上运行的代码。</p>

<p>一个文件中的代码可能指向另一个文件的位置，而<strong>链接器</strong>能够解决外部内存地址的问题。</p>

<p>最后<strong>加载器</strong>把所有的可执行目标文件放到内存中执行。</p>

<hr />

<h2>编译器的结构</h2>

<p>编译器能够把源程序映射为在语义上等价的目标程序，这个映射过程由两部分组成：<strong>分析</strong>部分和<strong>综合</strong>部分。</p>

<ul>
	<li><strong>分析部分把源程序分解成为多个组成要素，并在这些要素之上加上语法结构。然后它使用这个结构来创建该源程序的一个中间表示</strong>。如果分析部分检查出源程序没有按照正确的语法构成，或者语义上不一致，它就必须提供有用的信息，使用户可以按此进行改正。<strong>分析部分还会收集有关源程序的信息，并把信息存放在一个称为符号表的数据结构中。符号表和中间表示形式一起传送给综合部分</strong>；</li>
	<li><strong>综合部分根据中间表示和符号表中的信息来构造用户期待的目标程序</strong></li>
</ul>

<p>一般将分析部分称为编译器的前端，而综合部分称为后端。</p>

<p>整个编译过程顺序执行了一组步骤，每个步骤把源程序的一种表示方法转换成另一种表示方法。一个典型的把编译程序分解成为多个步骤的方式如下图所示：</p>

<figure><img src="/Users/xerxes/note/compile/src/%E7%BC%96%E8%AF%91%E6%AD%A5%E9%AA%A4.png"/></figure>

<p>在实践中，多个步骤可能被组合在一起，而这些组合在一起的步骤之间的中间表示不需要被明确地构造出来。存放整个源程序的信息的符号表可由编译器的各个步骤使用。</p>

<p>有些编译器在前端和后端之间有一个与机器无关的优化步骤，这个步骤的目的是在中间表示之上进行转换，以便后端程序能够生成更好的目标程序。基于未经过优化的中间表示来生成代码，代码质量会受到影响。优化步骤是可选的。</p>

<h3>词法分析</h3>

<p>编译器的第一个步骤称为<strong>词法分析（lexical analysis）</strong>或<strong>扫描（scanning）</strong>。</p>

<p><strong>词法分析器读入组成源程序的字符流，并且将它们组织成为有意义的词素（lexeme）的序列</strong>。对于每个词素，词法分析器产生如下形式的<strong>词法单元（token）</strong>作为输出：</p>

<pre><code>&lt;token-name, attribute-value&gt;
</code></pre>

<p>词法单元中第一个分量<code>token-name</code>是一个由语法分析步骤使用的抽象符号；第二个分量<code>attribute-value</code>指向符号表中关于这个词法单元的条目，条目中存放该标识符有关的信息如名字和类型，符号表条目的信息会被语义分析和代码生成步骤使用。</p>

<p>比如一个源程序包含如下语句：</p>

<pre><code>position = initial + rate * 60
</code></pre>

<p>该语句中的字符可以组合成如下词素，并映射成为如下词法单元：</p>

<ul>
	<li><code>position</code> 是一个词素，被映射成词法单元<code>&lt;id, 1&gt;</code>，其中id 是表示<strong>标识符（identifier）</strong>的抽象符号，而1指向符号表中position 对应的条目；</li>
	<li>赋值符号<code>=</code>是一个词素，被映射成词法单元<code>&lt;=&gt;</code>。因为这个词法单元不需要属性值，所有省略第二个分量。也可以使用<code>assign</code> 这个的抽象符号作为词法单元的名字，但是为了标记上的方便，选择使用词素本身作为抽象符号的名字；</li>
	<li><code>initial</code>是一个词素，被映射成词法单元<code>&lt;id, 2&gt;</code>，其中2指向initial 对应的符号表条目；</li>
	<li><code>+</code>是一个词素，被映射成词法单元<code>&lt;+&gt;</code>；</li>
	<li><code>rate</code>是一个词素，被映射成词法单元<code>&lt;id, 3&gt;</code>，其中3指向rate 对应的符号表条目；</li>
	<li><code>*</code>是一个词素，被映射词法单元<code>&lt;*&gt;</code>；</li>
	<li><code>60</code>是一个词素，被映射词法单元<code>&lt;60&gt;</code></li>
	<li>分割词素的空格会被词法分析器忽略掉</li>
</ul>

<p>语句经过词法分析之后，表示成如下词法单元序列：</p>

<pre><code>&lt;id, 1&gt;&lt;=&gt;&lt;id, 2&gt;&lt;+&gt;&lt;id, 3&gt;&lt;*&gt;&lt;60&gt;
</code></pre>

<figure><img src="/Users/xerxes/note/compile/src/%E4%B8%80%E4%B8%AA%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%BF%BB%E8%AF%91.png"/></figure>

<h3>语法分析</h3>

<p>编译器第二个步骤称为<strong>语法分析（syntax analysis）</strong>或<strong>解析（parsing）</strong>。</p>

<p><strong>语法分析器使用词法分析器生成的词法单元的第一个分量来创建树形的中间表示，该中间表示给出了词法分析产生的词法单元流的语法结构</strong>。一个常用的表示方法是<strong>语法树（syntax tree）</strong>，树中每个内部节点表示一个运算，而该节点的子节点表示该运算的分量。</p>

<h3>语义分析</h3>

<p><strong>语义分析器（semantic analyzer）使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致</strong>。它同时也收集类型信息，并把这些信息存放在语法树或符号表中，以便在随后的中间代码生成过程中使用。</p>

<p>语义分析的一个重要部分是<strong>类型检查（type checking）</strong>。编译器检查每个运算符是否具有匹配的运算分量。比如很多程序设计语言的定义中要求一个数组的下标必须是整数，如果用一个浮点数作为数组下标，编译器就必须报告错误。</p>

<p>程序设计语言可能允许某些类型转换，这被称为<strong>自动类型转换（coercion）</strong>。比如一个二元算术运算符可以应用于一对整数或者一对浮点数。如果这个运算符应用于一个浮点数和一个整数，那么编译器可以把该整数转换成为一个浮点数。</p>

<h3>中间代码生成</h3>

<p>在把一个源程序翻译成目标代码的过程中，一个编译器可能构造出一个或多个中间表示，这些中间表示可以有多种形式，例如语法树就是一种中间表示形式。</p>

<p><strong>在源程序的语法分析和语义分析完成之后，很多编译器会生成一个明确的低级的或类机器语言的中间表示，可以把这个表示看作是某个抽象机器的程序</strong>。该中间表示应该具有两个重要的性质：易于生成，且能够被轻松地翻译为目标机器上的语言。</p>

<p>如上面的例子中，中间代码生成器的输出为：</p>

<pre><code>t1 = inttofloat(60)
t2 = id3 * t1
t3 = id2 + t2
id1 = t3
</code></pre>

<p>这是一种<strong>三地址代码（three-address code）</strong>中间表示形式，这种中间表示由一组类似于汇编语言的指令组成，每个指令具有三个运算分量，每个运算分量都像一个寄存器。</p>

<p>每个三地址赋值指令的右部最多只有一个运算符。因此这些指令确定了运算完成的顺序。</p>

<p>编译器应该生成一个临时名字以存放一个三地址指令计算得到的值。</p>

<p>有些三地址指令的运算分量少于三个。</p>

<h3>代码优化</h3>

<p><strong>使用一个简单的中间代码生成算法，然后再进行代码优化步骤是生成优质目标代码的一个合理方法</strong>。</p>

<p>机器无关的代码优化步骤试图改进中间代码，以便生成更好的目标代码。更好可能意味着更快、更短或能耗更低。</p>

<p>如上例子中，优化器可以得出结论：把60从整数转换为浮点数的运算可以在编译时刻一劳永逸地完成。因此用浮点数60.0代替整数60就可以消除相应的inttofloat 运算。而且t3仅被使用一次，用来把它的值传递给id1。因此优化器把上一步的中间代码转换为更短的指令序列：</p>

<pre><code>t1 = id3 * 60.0
id1 = id2 + t1
</code></pre>

<p>不同编译器所做的代码优化工作量相差很大，那些优化工作做得最多的编译器，即所谓的“优化编译器”，会在优化阶段花相当多的时间。</p>

<h3>代码生成</h3>

<p><strong> 代码生成器以源程序的中间表示形式作为输入，并把它映射到目标语言</strong>。</p>

<p>如果目标语言是机器代码，那么就必须为程序使用的每个变量选择寄存器或内存位置。</p>

<p>代码生成的一个至关重要的方面是合理分配寄存器以存放变量的值。</p>

<p>例如使用寄存器R1和R2，上一步的中间代码会被翻译为如下机器代码：</p>

<pre><code>LDF R2, id3
MULF R2, R2, #60.0
LDF R1, id2
ADDF R1, R1, R2
STF id1, R1
</code></pre>

<p>每个指令的第一个运算分量指定了一个目标地址。各个指令中的F 告诉我们它处理的是浮点数。</p>

<p>这段代码把地址id3中的内容加载到寄存器R2中，然后将其与浮点常数60.0相乘。‘#’代表60.0应该作为一个立即数处理。接下来把id2移动到寄存器R1中，然后把前面计算并保存在R2的值加到R1上。最后把寄存器R1中的值存放到id1的地址中。</p>

<h3>符号表管理</h3>

<p>编译器的重要功能之一是<strong>记录源程序中使用的变量和名字，并收集和每个名字的各种属性有关的信息</strong>。这些属性可以提供一个名字的存储分配、它的类型、作用域（即程序的哪些地方可以使用这个名字的值）等信息。</p>

<p>对于过程名字，这些信息还包括：它的参数数量和类型、每个参数的传递方法（比如值传递还是引用传递）以及返回类型。</p>

<p><strong>符号表为每个变量名字创建一个记录条目，记录的字段就是名字的各个属性</strong>。</p>

<h3>将多个步骤组合成趟</h3>

<p>前面关于步骤的讨论讲的是一个编译器的逻辑组织方式，在一个特定的实现中，<strong>多个步骤的活动可以组织成一趟，每趟读入一个输入文件并产生一个输出文件</strong>。</p>

<p>比如前端步骤中的词法分析、语法分析、语义分析以及中间代码生成可以组合成一趟，代码优化可以作为一个可选的趟，然后可以有一个为特定目标机生成代码的后端趟。</p>

<p>有些编译器集合是围绕一组精心设计的中间表示形式而创建的，这些中间表示形式使得我们可以把特定语言的前端和特定目标机的后端相结合。</p>

<h3>编译器构造工具</h3>

<p>和软件开发一样，写编译器的人可以充分利用现代的软件开发工具，包括语言编辑器、调试器、版本管理、程序描述器、测试管理等工具。</p>

<p>除了这些通用的软件开发工具，人们还创建了一些更加专业的工具来实现编译器的不同阶段。这些工具使用专用的语言来描述和实现特定的组件，其中的很多工具易于和编译器的其他部分集成。一些常用的编译器构造工具如：</p>

<ul>
	<li>语法分析器的生成器：可以根据一个程序设计语言的语法描述自动生成语法分析器；</li>
	<li>扫描器的生成器：可以根据一个语言的语法单元的正则表达式描述生成词法分析器；</li>
	<li>语法制导的翻译引擎：可以生成一组用于遍历分析树并生成中间代码的例程；</li>
	<li>代码生成器的生成器：依据一组关于如何把中间语言的每个运算翻译成为目标机上的机器语言的规则，生成一个代码生成器；</li>
	<li>数据流分析引擎：可以帮助收集数据流信息，即程序中的值如何从程序的一个部分传递到另一个部分。是代码优化的一个重要部分；</li>
	<li>编译器的构造工具集：提供了可用于构造编译器的不同阶段的例程的完整集合</li>
</ul>

<hr />

<h2>构建一个编译器的相关科学</h2>

<p>编译器的设计中有很多通过数学方法抽象出问题本质，从而解决现实世界中复杂问题的完美例子。</p>

<h3>编译器设计和实现中的建模</h3>

<p><strong>对编译器的研究主要是有关如何设计正确的数学模型和选择正确算法的研究</strong>。设计和选择时，还需要考虑对通用型及功能的要求与简单性及有效性之间的平衡。</p>

<p>最基本的数学模型如<strong>有穷状态自动机</strong>和<strong>正则表达式</strong>。这些模型可以用于<strong>描述程序的词法单位（关键字、标识符等）</strong>以及<strong>描述被编译器用来识别这些单位的算法</strong>。</p>

<p>最基本的模型还包括<strong>上下文无关文法</strong>，它用于描述<strong>程序设计语言的语法结构</strong>，比如嵌套的括号和控制结构。</p>

<p>类似地，<strong>树形结构</strong>是表示<strong>程序结构以及程序到目标代码的翻译方法</strong>的重要模型。</p>

<h3>代码优化的科学</h3>

<p>在编译器的设计中，<strong>优化是指编译器为了生成比浅显直观的代码更加高效的代码而做的工作</strong>。</p>

<p>人们已经围绕代码优化建立了一套广泛且有用的理论。应用严格的数学基础，使得我们可以证明一个优化是正确的，并且它对所有可能的输入都产生预期的效果。（如果想使得编译器产生经过良好优化的代码，图、矩阵和线性规划之类的模型是必不可少的）。</p>

<p>从另一方面来说只有理论是不够的，我们在编译器优化中提出的很多问题都是不可判定的。<strong>在编译器设计中，最重要的技能之一是明确描述出真正要解决的问题的能力</strong>。</p>

<p>编译器优化必须满足下面的设计目标：</p>

<ul>
	<li>优化必须是正确的，不能改变被编译的程序的含义；</li>
	<li>优化必须能够改善很多程序的性能；</li>
	<li>优化所需的时间必须保持在合理的范围内；</li>
	<li>所需要的工程方面的工作必须是可管理的</li>
</ul>

<hr />

<h2>编译技术的应用</h2>

<h3>高级程序设计语言的实现</h3>

<p>一个高级程序设计语言定义了一个编程抽象：程序员使用这个语言表达算法，而编译器必须把这个程序翻译成目标语言。</p>

<h3>针对计算机体系结构的优化</h3>

<p>计算机体系结构的快速发展也对新编译器技术提出了越来越多的需求。几乎所有高性能系统都利用了两种技术：<strong>并行</strong>和<strong>内存层次结构</strong>。</p>

<p>并行性和内存层次结构的存在都会提高一个机器的潜在性能，但是它们必须被编译器有效利用才能够真正为一个应用提供高性能计算。</p>

<p>并行可以出现在多个层次上：在指令层次上，多个运算可以被同时执行；在处理器层次上，同一个应用的多个不同线程在不同的处理器上运行。</p>

<p>内存层次结构是应对下述局限性的方法：我们可以制造非常快的内存，或者非常大的内存，但是无法制造又快又大的内存。</p>

<h4>并行性</h4>

<p>所有的现代微处理器都采用了指令级并行性。但是这种并行性可以对程序员隐藏。程序员写程序的时候就好像所有指令都是顺序执行的。硬件动态地检测顺序指令流之间的依赖关系，并且在可能的时候并行地发出指令。</p>

<p>在有些情况下，机器包含一个硬件调度器。该调度器可以改变指令的顺序以提高程序的并行性。不管硬件是否对指令进行重新排序，编译器都可以重新安排指令，以使得指令级并行更加有效。</p>

<p><strong>指令级并行也显式地出现在指令集中</strong>。VLIW（Very Long Instruction Word，非常长指令字）机器拥有可并行执行多个运算的指令。<strong>所有的高性能通用微处理器还包含了可以同时对一个向量中的所有数据进行运算的指令</strong>。人们已经开发出了相应的编译器技术，从顺序程序出发为这样的机器自动生成代码。</p>

<h4>内存层次结构</h4>

<p>一个内存层次结构由几层具有不同速度和大小的存储器组成，离处理器最近的层速度最快但是容量最小。如果一个程序的大部分内存访问都能由层次结构中最快的层满足，那么程序的平均内存访问时间就会降低。</p>

<p>系统性能经常受到内存子系统的性能的限制，虽然一般来说编译器注重优化处理器的执行，现在人们更多的强调如何使内存层次结构更加高效。</p>

<p>和寄存器必须由软件明确管理不同，高速缓存和物理内存是对指令集合隐藏的，并由硬件管理。</p>

<p>由硬件实现的高速缓存管理策略有时并不高效。当处理具有大型数据结构的科学计算代码时更是如此。我们可以<strong>改变数据的布局或数据访问代码的顺序来提高内存层次结构的效率</strong>，也可以<strong>通过改变代码的布局来提高指令高速缓存的效率</strong>。</p>

<h3>新计算机体系结构的设计</h3>

<p>在计算机体系结构设计的早期，编译器是在机器建造好之后再开发的。现在情况改变了，因为使用高级程序设计语言是一种规范，决定一个计算机系统性能的不是它的原始速度，还包括编译器能够以何种程度利用其特征。</p>

<p>因此在现代计算机体系结构的开发中，编译器在处理器设计阶段就进行开发，然后编译得到代码并运行在模拟器上，这些代码被用来评价提议的体系结构特征。</p>

<h4>RISC</h4>

<p>有关编译器如何影响计算机体系结构设计的最有名的例子之一是<strong>RISC</strong>的发明。</p>

<p>在发明RISC 之前，趋势是开发的指令集越来越复杂，以使得汇编编程变得更容易。这种体系结构称为<strong>CISC</strong>。比如CISC 指令集包含了复杂的内存寻址模式来支持对数据结构的访问。</p>

<p>编译器优化经常能消除复杂指令之间的冗余，把这些指令削减为少量较简单的运算。因此人们期望设计出简单指令集，编译器可以有效地使用它们，而硬件也更容易进行优化。</p>

<h4>专用体系结构</h4>

<p>过去提出过很多体系结构概念，如数据流机器、向量机、VLIW（非常长指令字）机器、SIMD（单指令，多数据）处理器阵列、心动阵列、共享内存的多处理器、分布式内存的多处理器。每种体系结构概念的发展都伴随着相应编译器技术的研究和发展。</p>

<h3>程序翻译</h3>

<p>通常把编译看作是从一个高级语言到机器语言的翻译过程。</p>

<p>同样的技术也可以应用到不同种类的语言之间的翻译。</p>

<h4>二进制翻译</h4>

<p>编译器技术可以用于把一个机器的二进制代码翻译成另一个机器的二进制代码，使得可以在一个机器上运算原本为另一个指令集编译的程序。</p>

<h4>硬件合成</h4>

<p>不仅仅大部分软件是用高级语言描述的，连大部分硬件设计也是使用高级硬件描述语言描述的，如Verilog 语言和VHDL（Very high-speed integrated circuit Hardware Description Language，甚高速集成电路硬件描述语言）。</p>

<p>硬件设计通常是在<strong>寄存器传输层（Register Transfer Level，RTL）</strong>上描述的。在这层中，变量代表寄存器，而表达式代表组合逻辑。<strong>硬件合成工具把RTL 描述自动翻译成为门电路，而门电路再被翻译成为晶体管，最后生成一个物理布局</strong>。</p>

<h4>数据查询解释器</h4>

<p>除了描述软件和硬件，语言在很多应用中都是有用的，如SQL 可以被解释，也可以编译为代码。</p>

<h3>软件生成率工具</h3>

<p>要使程序能够完全正确运行，每个细节都必须是正确的，测试是对系统中的错误进行定位的主要技术。</p>

<p><strong>通过数据流分析技术静态地（即在程序运行之前）定位错误</strong>是一个辅助性方法。数据流分析可以在所有可能的执行路径上找到错误，而不是像程序测试的时候所做的那样，只是在那些由输入数据组合执行的路径上找错误。</p>

<h4>类型检查</h4>

<p>类型检查可以用于捕捉程序中的不一致性。</p>

<p>它可以用来检测一些错误，比如运算被用于错误类型的对象上，或者传递给一个过程的参数和该过程的范型不匹配。</p>

<p>通过分析程序中的数据流，程序分析还可以做出比检查类型错误更多的工作，如一个指针被赋予了NULL，然后又立刻被释放了，这个程序显然是错误的。</p>

<h4>边界检查</h4>

<p>相对于较高级的程序设计语言，用较低级语言编程更加容易犯错。比如很多系统中的安全漏洞都是因为用C 编写的程序中的缓冲区溢出造成的。因为C 没有数组边界检查，所以必须由用户来保证对数组的访问没有超出边界。</p>

<p>如果程序是用一种包含了自动区间检查的安全的语言编写的，就不会发生这样的问题。</p>

<p>用来消除程序中的冗余区间检查的数据流分析技术也可以用来定位缓冲区溢出错误。而最大区别在于没能消除某个区间检查仅仅会导致很小的额外运行时刻消耗，而没有指出一个潜在的缓冲区溢出错误却可能危及系统安全性。</p>

<p>因此虽然使用简单的技术去进行区间检查优化就已经足够了，但在错误探测工具中获得高质量的结果则需要复杂的分析技术，如在过程之间跟踪指针值的技术。</p>

<h4>内存管理工具</h4>

<p>垃圾收集机制是在效率和易编程及软件可靠性之间进行折中处理的一个例子。</p>

<p>自动的内存管理消除了所有的内存管理错误（如内存泄漏）。</p>

</body>
</html>

