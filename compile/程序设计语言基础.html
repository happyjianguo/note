<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>程序设计语言基础</title>
	</head>
<body>
<h1>程序设计语言基础</h1>

<hr />

<h2>静态与动态</h2>

<p>在为一个语言设计一个编译器时，我们所面对的最重要的问题之一是编译器能够对一个程序作出哪些判定。</p>

<p>如果一个语言使用的策略支持编译器静态决定某一个问题，那么称这个语言使用了一个<strong>静态策略</strong>，或者说这个问题可以在<strong>编译时刻（compile time）</strong>决定。</p>

<p>另一方面，一个只允许在运行程序的时候做出决定的策略称为<strong>动态策略</strong>，或者被认为需要在<strong>运行时刻（run time）</strong>作出决定。</p>

<p>需要注意的另一个问题是<strong>声明的作用域</strong>。x 的一个<strong>声明的作用域是指程序的一个区域，在其中对x 的使用都指向这个声明</strong>。</p>

<p>如果仅通过阅读程序就可以确定一个声明的作用域，那么这个语言使用的是<strong>静态作用域</strong>，或者说<strong>词法作用域</strong>。否则这个语言使用的是<strong>动态作用域</strong>。</p>

<p>如果使用动态作用域，当程序运行时，同一个对x 的使用会指向x 的几个声明中的某一个。</p>

<p>以Java 类声明中的<code>static</code>为例，这个术语作用于数据。在Java 中，一个变量是用于存放数据值的某个内存位置的名字。这里<code>static</code>指的并不是变量的作用域，而是<strong>编译器确定用于存放被声明变量的内存位置的能力</strong>。例如<code>public static int x</code>，使得x 成为一个类变量，即不管创建了多少个这个类的对象，只存在一个x 的拷贝。并且编译器可以确定内存中被用于存放整数x 的位置。</p>

<p>如果不带<code>statis</code>，这个类的每个对象都会有它自己的用于存放x 的位置，编译器没办法在运行程序之前先确定这些位置。</p>

<hr />

<h2>环境与状态</h2>

<p>变量名和内存存储位置的关联，及之后和值的关联可以用两个映射来描述，这两个映射随着程序的运行而改变：</p>

<ul>
	<li>环境（environment）：是一个从名字到存储位置的映射。因为变量就是指内存位置，所以也可以把环境定义为从名字到变量的映射。环境的改变需要遵守语言的作用域规则；</li>
	<li>状态（state）：是一个从内存位置到它们的值的映射</li>
</ul>

<figure><img src="/Users/xerxes/note/compile/src/%E5%90%8D%E5%AD%97%E5%88%B0%E5%80%BC%E7%9A%84%E6%98%A0%E5%B0%84.png"/></figure>

<p>术语‘名字’和‘变量’通常指的是同一个事物，但还是应该小心区分<strong>编译时刻的名字</strong>和<strong>名字在运行时刻所指的内存位置</strong>。</p>

<p>以如下C 程序代码为例：</p>

<figure><img src="/Users/xerxes/note/compile/src/%E5%90%8D%E5%AD%97i%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%A3%B0%E6%98%8E.png"/></figure>

<p>整数i 首先被省名为一个全局变量，同时又被省名为局部于函数f 的变量。</p>

<p>执行f 时，环境相应地调整，使得名字i 指向为局部于f 的i 所保留的存储位置，且i 的所有使用都指向这个位置。局部的i 通常被赋予一个运行时刻栈中的位置。</p>

<p>当不同于f 的函数g 运行时，i 的使用就不能指向那个局部于f 的i。在函数g 中对名字i 的使用必须为于其他某个对i 的声明的作用域内。</p>

<p>环境和状态映射并不总是动态的：</p>

<ul>
	<li>名字到位置的静态绑定与动态绑定：大部分从名字到位置的绑定是动态的。而有些声明（如上面例子中的全局变量）可以在编译器生成目标代码时一劳永逸地分配一个存储位置；</li>
	<li>从位置到值的静态绑定与动态绑定：一般来说，位置到值的绑定也是动态的，因为无法在运行一个程序之前指出一个位置上的值。除非声明一个常量</li>
</ul>

<hr />

<h2>静态作用域和块结构</h2>

<p>包括C 语言和它的同类语言在内的大多数语言使用静态作用域。C 语言的作用域规则是基于程序结构的，一个声明的作用域由该声明在程序中出现的位置隐含的决定。</p>

<p>标识符是一个字符串，通常由字母和数字组成。用来指向一个实体，比如一个数据对象、过程、类或者类型。所有标识符都是名字，但并不是所有名字都是标识符。名字也可以是一个表达式。</p>

<p>同一个标识符可以被多次声明，每一个声明引入一个新的变量。即使每个标识符只被声明一次，一个递归过程中的局部标识符将在不同的时刻指向不同的存储位置。</p>

<p><strong>C 语言的静态作用域策略</strong>可以概述如下：</p>

<ul>
	<li>一个C 程序由一个顶层的变量和函数声明的序列组成；</li>
	<li>函数内部可以声明变量，变量包括局部变量和参数。每个这样的声明的作用域被限制在它们所出现的那个函数内；</li>
	<li>名字x 的一个顶层声明的作用域包括其后的所有程序。但是如果一个函数中也有一个x 的声明，那么函数中的那些语句就不在这个顶层声明的作用域内；</li>
</ul>

<p><strong>C 语言中有关块的语法</strong>如下：</p>

<ul>
	<li>块是一种语句，块可以出现在其他类型的语句所能够出现的任何地方；</li>
	<li>一个块包含了一个声明的序列，然后再跟着一个语句序列，这些声明和语句用一对括号包起来</li>
</ul>

<p>块的语法允许一个块嵌套在另一个块内。这个嵌套特性被称为<strong>块结构</strong>。</p>

<hr />

<h2>显式访问控制</h2>

<p>类和结构为它们的成员引入了新的作用域。</p>

<p>如果p 是一个具有成员x 的类的对象，那么p.x 中对x 的使用指的是这个类定义中的成员x。类C 中的一个成员声明x 的作用域可以扩展到所有的子类，除非子类有一个本地的对同一个名字x 的声明。</p>

<p>通过<code>public</code>、<code>private</code>和<code>protected</code>这样的关键字，Java 这样的面向对象语言提供了对超类中成员名字的显示访问控制。这些关键字通过限制访问来支持封装。</p>

<hr />

<h2>动态作用域</h2>

<p>从技术上讲，如果一个作用域策略依赖于一个或多个只有在程序执行时刻才能知道的因素，它就是动态的。</p>

<p>动态作用域通常指的是如下策略：<strong>对一个名字x 的使用指向的是最近被调用但还没有终止且声明了x 的过程中的这个声明</strong>。</p>

<p>动态作用域解析对多态过程是必不可少的。所谓多态过程是指对于同一个名字根据参数类型具有两个或多个定义的过程。</p>

<p>面向对象语言的一个突出特征就是每个对象能够对一个消息作出适当反应，调用相应的方法。例如：</p>

<ol>
	<li>有一个类C，有一个名字为<code>m()</code>的方法；</li>
	<li>D 是C 的一个子类，D 也有一个叫<code>m()</code>的方法；</li>
	<li>有一个形如<code>x.m()</code>的对x 的使用，x 是类C 的一个对象</li>
</ol>

<p>正常情况下，在编译时刻不可能指出x 指向的是类C 的对象还是类D 的对象。如果这个方法被多次应用，那么很可能某些调用作用在由x 指向类C 的对象，而其他调用作用于类D 的对象。</p>

<p>只有到了运行时刻才可能决定应当调用m 的哪个定义。因此编译器生成的代码必须决定对象x 的类，并调用其中某一个名字为m 的方法。</p>

<h3>静态作用域和动态作用域的类比</h3>

<p>虽然可以有各种各样的静态或者动态作用域策略，在通常的静态作用域规则和通常的动态策略之间有一个有趣的关系。</p>

<p>从某种意义上说，动态规则处理时间的方式类似于静态作用域处理空间的方式。</p>

<p>静态规则让我们寻找的声明位于最内层的、包含变量使用位置的单元中；而动态规则让我们寻找的声明位于最内层的、包含了变量使用时间的单元中。</p>

<hr />

<h2>参数传递机制</h2>

<p>所有的程序设计语言都有关于过程的概念，但是在这些过程如何获取它们的参数方面，不同语言各不相同。</p>

<p>那么实在参数（在调用过程时使用的参数）是如何与形式参数（在过程定义中使用的参数）关联起来的呢？</p>

<p>使用哪一种传递机制决定了调用代码序列如何处理参数。</p>

<h3>值调用（call-by-value）</h3>

<p>在值调用中，会对实参求值（如果它是表达式）或拷贝（如果它是变量）。这些值被放在属于被调用过程的相应形参的内存位置上。</p>

<p>C 和Java 中都使用值调用。</p>

<p>值调用的效果是，<strong>被调用过程所做的所有有关形参的计算都局限于这个过程，相应的实参本身不会被改变</strong>。</p>

<p>然而，在C 语言中可以传递变量的一个指针，使得该变量的值能够被调用者修改。</p>

<p>同样的，C、Java 中作为参数传递的数组名字实际上向被调用过程传递了一个指向该数据本身的指针或引用。</p>

<p>例如a 是调用过程的一个数组的名字，且它被以值调用的方式传递给相应的形式参数x，那么像<code>x[2] = i</code>这样的赋值语句实际上改变了数组元素<code>a[i]</code>。原因是虽然x 是a 的值的拷贝，但这个值实际上是一个指针，只想被分配给数组a 的存储区域的开始位置。</p>

<p>类似的，Java 中很多变量实际上是对它们所代表的事物的引用/指针。这个结论对数组、字符串和所有类的对象都有效。<strong>虽然Java 只使用值调用，但只要把一个对象的名字传递给一个被调用过程，那个过程收到的值实际上是这个对象的指针</strong>。</p>

<p>因此，被调用过程是可以改变这个对象本身的值的。</p>

<h3>引用调用（call-by-reference）</h3>

<p><strong>实参的地址作为相应的形参的值被传递给被调用者，在被调用者的代码中使用形参时，实现方法是沿着这个指针找到调用者指明的内存位置</strong>。因此改变形参看起来像是改变了实参一样。</p>

<p>但是如果实参是一个表达式，那么在调用之前首先对表达式求值，然后它的值被存放在一个该值自己的位置上。改变形参会改变这个位置上的值，但对调用者的数据没有影响。</p>

<p>严格的值调用要求调用者把整个实参拷贝到属于相应形参的空间上，当参数很大时，这种拷贝可能代价高昂。像Java 这样的语言解决数组、字符串和其他对象的参数传递问题的方法仅仅是复制这些对象的引用。结果是Java 运行时就好像它对所有不是基本类型（如整数）的参数都使用了引用调用。</p>

<hr />

<h2>别名</h2>

<p>引用调用或其他类似的方法，比如像<strong>Java 中那样把对象的引用当作值传递</strong>，会引起一个结果：有可能两个形参指向同一个位置，这样的变量称为另一个变量的别名。</p>

<p>结果是任意两个看起来从两个不同的形参中获得值的变量也可能变成对方的别名。</p>

<p>假设a 是一个属于某个过程p 的数组，且p 通过调用语句<code>q(a, a)</code>调用了另一个过程<code>q(x, y)</code>。如果是C 语言那样参数是通过值传递的，但数组名实际上是指向数组存放位置的引用。现在x 和y 变成了对方的别名。此时如果q 中有一个赋值语句<code>x[10] = 2</code>，那么<code>y[10]</code>的值也是2。</p>

<p>如果编译器要优化一个程序，就要理解别名现象以及产生这一现象的机制。</p>

</body>
</html>

