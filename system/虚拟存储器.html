<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>虚拟存储器</title>
	</head>
<body>
<h1>虚拟存储器</h1>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({tex2jax: {inlineMath:[['$','$']]}});
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<p>为了更加有效地管理存储器，现代系统提供了一种对主存的抽象概念，叫做<strong>虚拟存储器</strong>。</p>

<p>虚拟存储器是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它<strong>为每个进程提供了一个大的、一致的私有的地址空间</strong>。</p>

<p>通过一个很清晰的机制，虚拟存储器提供了三个重要的能力：</p>

<ul>
	<li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据；</li>
	<li>它为每个进程提供了一致的地址空间，从而简化了存储器管理；</li>
	<li>它保护了每个进程的地址空间不被其他进程破坏</li>
</ul>

<hr />

<h2>物理和虚拟寻址</h2>

<p><strong>计算机系统的主存被组织成一个由M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址（Physical Address）</strong>。第一个字节的地址为0，接下来的字节地址为1，依此类推。</p>

<p>CPU 访问存储器的最自然的方式就是使用物理地址，这种方式称为<strong>物理寻址</strong>。</p>

<p>现代CPU 使用的是一种称为<strong>虚拟寻址</strong>的方式，如下图：</p>

<figure><img src="/Users/xerxes/note/system/src/%E8%99%9A%E6%8B%9F%E5%AF%BB%E5%9D%80.png"/></figure>

<p>使用虚拟寻址时，CPU 通过生成一个<strong>虚拟地址（Virtual Address，VA）</strong>来访问主存，这个虚拟地址在被送到存储器之前先转换成物理地址。将一个虚拟地址转换为物理地址的任务叫做<strong>地址翻译</strong>。CPU 芯片上的<strong>存储器管理单元（Memory Management Unit，MMU）</strong>利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。</p>

<hr />

<h2>地址空间</h2>

<p><strong>地址空间</strong>是一个非负整数地址的有序集合。</p>

<p>如果地址空间中的整数是连续的，那么我们说它是一个<strong>线性地址空间</strong>。</p>

<p>在一个带虚拟存储器的系统中，CPU 从一个有N 个地址的地址空间生成虚拟地址，这个地址空间称为<strong>虚拟地址空间</strong>。一个地址空间的大小由表示最大地址所需要的位数来描述。如一个包含$N = 2^n$个地址的虚拟地址空间就叫做一个n 位地址空间。现代系统典型地支持32位或者64位虚拟地址空间。</p>

<p>一个系统还有一个<strong>物理地址空间</strong>，它与系统中物理存储器的M 个字节相对应。</p>

<p><strong>地址空间清楚地区分了数据对象和它们的地址，每个数据对象有多个独立的地址，其中每个地址选自一个不同的地址空间，这就是虚拟存储器的基本思想</strong>。主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p>

<hr />

<h2>虚拟存储器作为缓存</h2>

<p><strong>虚拟存储器被组织为一个由存放在磁盘上的N 个连续的字节大小的单元组成的数组，每个字节都有一个唯一的虚拟地址，这个唯一的虚拟地址作为数组的索引</strong>。</p>

<p>磁盘上的数据被分割成<strong>块</strong>，作为磁盘和主存之间的传输单元。</p>

<p>VM 系统通过将虚拟存储器分割为<strong>虚拟页（Virtual Page，VP）</strong>的大小固定的块来处理这个问题。每个虚拟页的大小为$P = 2^p$字节。</p>

<p>类似的，物理存储器被分割为<strong>物理页（Physical Page，PP）</strong>，大小也为P 字节。物理页也被称为页帧（page frame）。</p>

<p>在任意时刻，虚拟页的集合都分为三个不相交的子集：</p>

<ul>
	<li>未分配的：VM 系统还未分配的页，不占用任何磁盘空间；</li>
	<li>缓存的：当前缓存在物理存储器中的已分配页；</li>
	<li>未缓存的：没有缓存在物理存储器中的已分配页</li>
</ul>

<figure><img src="/Users/xerxes/note/system/src/VM%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%B8%BB%E5%AD%98%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98.png"/></figure>

<p>如上图展示了一个有8个虚拟页的小虚拟存储器。</p>

<h3>DRAM 缓存的组织结构</h3>

<p>DRAM 缓存表示虚拟存储器系统的缓存，它在主存中缓存虚拟页。</p>

<p>DRAM 缓存是全相连的，任何虚拟页都可以放置在任何物理页中。</p>

<p>不命中的替换策略也很重要，与硬件对SRAM 缓存相比，操作系统DRAM 缓存使用了更复杂的替换算法。</p>

<h3>页表</h3>

<p>和任何缓存一样，虚拟存储器系统必须有某种方法来判定一个虚拟页是否存放在DRAM 上。如果是，还必须确定这个虚拟页存放在哪个物理页上。如果不命中，系统必须判断这个虚拟页存放在磁盘哪个位置，然后在物理存储器中选择一个牺牲品，将虚拟页从磁盘拷贝到DRAM 上，替换这个牺牲页。</p>

<p>这些功能是由许多软硬件联合提供的，包括操作系统软件、MMU 中的地址翻译硬件和一个存放在物理存储器中的<strong>页表</strong>。</p>

<p><strong>页表将虚拟页映射到物理页</strong>。每次地址翻译硬件将一个虚拟地址转换为物理地址时都会读取页表。操作系统负责维护页表的内容，以及在磁盘与DRAM 之间传送页。</p>

<figure><img src="/Users/xerxes/note/system/src/%E9%A1%B5%E8%A1%A8.png"/></figure>

<p>如上图展示了一个页表的基本组织结构。页表就是一个<strong>页表条目（Page Table Entry，PTE）</strong>的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE。每个PTE 是由一个有效位和一个n 位地址字段组成的。</p>

<p>有效位表明了该虚拟页当前是否被缓存在DRAM 上。如果设置了有效位，那么地址字段就表示DRAM 中相应的物理页的起始位置；如果没有有效位，那么空地址表示虚拟页还未被分配，有地址的就指向虚拟页在磁盘上的起始位置。</p>

<h3>page cache、buffer cache</h3>

<p><strong>page cache 用于缓存文件的页数据，buffer cache 用于缓存块设备（如磁盘）的块数据</strong>。</p>

<p>page 是逻辑上的概念，因此page cache 是与文件系统同级的；块是物理上的概念，因此buffer cache 是与块设备驱动程序同级的。</p>

<p>Page cache 和buffer cache 的目的都是<strong>加速数据I/O</strong>：</p>

<ul>
	<li>写数据时首先写到缓存，将写入的页标记为dirty，然后向外部存储flush，也就是缓存写机制中的write-back；</li>
	<li>读数据时首先读取缓存，如果未命中，再去外部存储读取，并且将读取来的数据也加入缓存</li>
</ul>

<p>操作系统总是积极的将所有空闲内存都用作page cache 和buffer cache，当内存不够用时也会用LRU 等算法淘汰缓存页。</p>

<p>在Linux 2.4版本的内核之前，page cache 和buffer cache 是完全分离的。但是块设备大多是磁盘，磁盘上的数据又大多通过文件系统来组织，这种设计导致很多数据被缓存了两次。</p>

<p>因此Linux 2.4版本内核之后，两块缓存近似地融合在了一起：<strong>如果一个文件的page 加载到了page cache，那么同时buffer cache 只需要维护块指向page 的指针就可以了</strong>。只有那些没有文件表示的块，或者绕过了文件系统直接操作的块才会真正放到buffer cache 中。</p>

<figure><img src="/Users/xerxes/note/system/src/%E9%A1%B5%E7%BC%93%E5%AD%98.png"/></figure>

<p>如上图近似的展示了32位操作系统中可能的一种page cache 结构，其中block size 为1KB，page size 为4KB。</p>

<p>Page cache 中的每一个文件都是一颗<strong>基数树（radix tree，本质上是多叉搜索树），树的每个节点都是一个页。根据文件内的偏移量就可以快速定位到所在的页</strong>。</p>

<h3>页命中</h3>

<p>假设CPU 读包含在VP 2中的虚拟存储器的一个字时。</p>

<figure><img src="/Users/xerxes/note/system/src/%E9%A1%B5%E5%91%BD%E4%B8%AD%E7%A4%BA%E4%BE%8B.png"/></figure>

<p>地址翻译硬件将虚拟地址作为一个索引定位PTE 2，并从页表中读取它。因为设置了有效位，那么地址翻译硬件就知道VP 2缓存在了DRAM 中，所以它使用PTE 中的物理存储器地址构造出这个字的物理地址。</p>

<h3>缺页</h3>

<p>DRAM 缓存未命中称为<strong>缺页</strong>。</p>

<p>假设CPU 读包含在VP 3中的虚拟存储器的一个字时。</p>

<p>地址翻译硬件从存储器中读取PTE 3，从有效位推断出VP 3未被缓存，触发了一个缺页异常。</p>

<p>缺页异常调用内核中的缺页异常处理程序，该程序选择存放在PP 3中的VP 4作为牺牲页。内核从磁盘拷贝VP 3到存储器中的PP 3，更新PTE 3，随后返回。</p>

<p>当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。此时VP 3已经被缓存在DRAM 中，正常执行页命中流程。</p>

<figure><img src="/Users/xerxes/note/system/src/%E7%BC%BA%E9%A1%B5%E7%A4%BA%E4%BE%8B.png"/></figure>

<h3>分配页</h3>

<figure><img src="/Users/xerxes/note/system/src/%E9%A1%B5%E5%88%86%E9%85%8D%E7%A4%BA%E4%BE%8B.png"/></figure>

<p>如图所示，通过在磁盘上创建空间并更新PTE 5，使它指向磁盘上这个新创建的页，从而分配VP 5。</p>

<hr />

<h2>虚拟存储器作为存储器管理</h2>

<p>操作系统实际上为每个进程提供了一个独立的页表，也就是一个独立的虚拟地址空间。</p>

<figure><img src="/Users/xerxes/note/system/src/%E8%BF%9B%E7%A8%8B%E7%8B%AC%E7%AB%8B%E9%A1%B5%E8%A1%A8.png"/></figure>

<p>如上图所示，不同进程的虚拟页可能映射到同一个共享物理页上。</p>

<p>VM 简化了链接和加载、代码和数据共享，以及应用程序的存储器分配。</p>

<h3>简化链接</h3>

<p>独立的地址空间允许每个进程的存储器映像使用相同的基本格式，而不管代码和数据实际存放在物理存储器的何处。</p>

<p>一致性极大简化了链接器的设计和实现，允许链接器生成全链接的可执行文件，这些可执行文件是独立于物理存储器中代码和数据的最终位置的。</p>

<h3>简化加载</h3>

<p>虚拟存储器还使得容易向存储器中加载可执行文件和共享对象文件。</p>

<h3>简化共享</h3>

<p>独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。</p>

<p>一般而言，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况下，操作系统创建页表，将相应的虚拟页映射到不同的物理页。</p>

<p>一些情况下，需要进程共享代码和数据。例如，每个进程必须调用相同的操作系统内核代码。操作系统通过将不同进程中适当的虚拟页映射到相同的物理页，从而安排多个进程共享这部分代码的一个拷贝。</p>

<h3>简化存储器分配</h3>

<p>虚拟存储器向用户进程提供了一个简单的分配额外存储器的机制。</p>

<p>当一个运行在用户进程中的程序要求额外的堆空间时，操作系统分配部分虚拟存储器页，并且将它们映射到物理存储器中任意位置的物理页。</p>

<p>由于页表的工作方式，操作系统没有必要分配连续的物理存储器页，页可以随机分散在物理存储器中。</p>

<hr />

<h2>虚拟存储器作为存储器保护</h2>

<p>任何现代计算机系统必须为操作系统提供手段来控制堆存储器系统的访问。不应该允许一个用户进程修改它的只读文本段。而且也不应该允许它读或修改任何内核中的代码和数据结构。不应该允许它读或者写其他进程的私有存储器，并且不允许它修改任何与其他进程共享的虚拟页，除非所有的共享者都显示地允许它这么做。</p>

<hr />

<h2>地址翻译</h2>

</body>
</html>

