<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>系统级I/O</title>
	</head>
<body>
<h1>系统级I/O</h1>

<p>I/O 是在主存和外部设备之间拷贝数据的过程。</p>

<hr />

<h2>Unix I/O</h2>

<p>所有的I/O 设备都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅的映射为文件的方式，允许Unix 内核引出一个简单、低级的应用接口，称为Unix I/O。</p>

<p>这使得所有的输入和输出都能以一种统一且一致的方式来执行打开文件、改变当前的文件位置、读写文件以及关闭文件。</p>

<h3>打开文件</h3>

<p>应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O 设备。</p>

<p>内核返回一个小的非负整数，叫做<strong>描述符</strong>，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息，应用程序只需记住这个描述符。</p>

<p>Unix shell 创建的每个进程开始时都有三个打开的文件：</p>

<ul>
	<li>标准输入：描述符为0；</li>
	<li>标准输出：描述符为1；</li>
	<li>标准错误：描述符为2</li>
</ul>

<h3>改变当前的文件位置</h3>

<p>对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。</p>

<p>应用程序能够通过执行seek 操作，显式地设置文件的当前位置为k。</p>

<h3>读写文件</h3>

<p>一个读操作就是从文件拷贝n 个字节到存储器，从当前文件位置k 开始，然后将k 增加到k+n。给定一个大小为m 字节的文件，当k &gt;= m 时执行读操作会触发一个称为end-of-file（EOF）的条件，应用程序能检测到这个条件。</p>

<p>类似的，写操作就是从存储器拷贝n 个字节到一个文件，从当前文件位置k 开始，然后更新k。</p>

<h3>关闭文件</h3>

<p>当应用程序完成了对文件的访问，它就通知内核关闭这个文件。</p>

<p>作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。</p>

<p>无论一个进程因为何种原因终止，内核都会关闭所有打开的文件并释放它们的存储器资源。</p>

<hr />

<h2>文件描述符fd</h2>

<p>Linux系统中，把一切都看作是文件。文件分为：普通文件、目录文件、链接文件和设备文件。</p>

<p>当进程打开现有文件或创建新文件时，内核向进程返回一个<strong>文件描述符</strong>，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件。</p>

<p><strong>所有执行I/O操作的系统调用都会通过文件描述符</strong>。</p>

<p>进程刚启动的时候，0是标准输入，1是标准输出，2是标准错误。此时打开一个新的文件，文件描述符会是3。POSIX标准要求每次打开文件时（含socket）必须使用当前进程中最小可用的文件描述符号码。</p>

<h3>文件描述符、文件、进程间的关系</h3>

<h4>描述</h4>

<ul>
	<li>每个文件描述符会与一个打开的文件相对应</li>
	<li>不同的文件描述符也可能指向同一文件</li>
	<li>相同的文件可以被不同的进程打开，也可以在同一个进程被多次打开</li>
</ul>

<h4>系统为维护文件描述符，建立了三张表</h4>

<ul>
	<li>进程级的文件描述符</li>
	<li>系统级的文件描述符</li>
	<li>文件系统的i-node表</li>
</ul>

<figure><img src="/Users/xerxes/note/system/src/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%BB%B4%E6%8A%A4%E8%A1%A8.jpg"/></figure>

<h4>表之间的关系</h4>

<figure><img src="/Users/xerxes/note/system/src/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB.jpg"/></figure>

<ul>
	<li>进程A中，文件描述符1和30都指向了同一个打开的文件句柄23，可能是该进程多次对该文件执行打开操作</li>
	<li>进程A中的文件描述符2和进程B的文件描述符2都指向了同一个打开的文件句柄73，有几种可能：

		<ul>
			<li>进程A和进程B是父子进程关系</li>
			<li>进程A和进程B打开了同一个文件，且文件描述符相同</li>
			<li>进程A和进程B中某进程通过UNIX域套接字将一个打开的文件描述符传递给另一个进程</li>
		</ul></li>
	<li>进程A的描述符0和进程B的描述符3分别指向不同的文件句柄，但句柄均指向i-node表的相同条目1936，也就是指向了同一文件。可能因为每个进程各自对同一个文件发起了打开请求，同一个进程两次打开同一个文件</li>
</ul>

<h4>文件描述符限制</h4>

<figure><img src="/Users/xerxes/note/system/src/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%99%90%E5%88%B6.jpg"/></figure>

<hr />

<h2>缓存I/O</h2>

<p>缓存I/O又称作标准I/O，大多数文件系统的默认I/O都是缓存I/O。</p>

<p>在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存（page cache）中，也就是说：<strong>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</strong>。</p>

<p>缓存I/O的缺点是：数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。</p>

</body>
</html>

