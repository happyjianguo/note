<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>同步、异步、阻塞和非阻塞</title>
	</head>
<body>
<h1>同步、异步、阻塞和非阻塞</h1>

<hr />

<h2>同步和异步</h2>

<p>这两个概念与消息的通知机制有关，主要是从消息通知机制角度来说的。</p>

<h3>同步</h3>

<p>当前任务的完成需要依赖另一个任务时，只有等待被依赖的任务完成后，当前任务才能算完成，这是一种可靠的任务序列。</p>

<h3>异步</h3>

<p>当前任务不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，当前任务也立即执行，只要自己完成了整个任务就算完成。</p>

<p>至于被依赖的任务最终是否真正完成，当前任务也无法确定，因此这是不可靠的任务序列。</p>

<h3>消息通知</h3>

<p>当一个异步过程调用发出后，调用者不能立刻得到返回消息，实际处理这个调用的部件在完成后，通过<strong>状态、通知和回调来通知调用者</strong>。使用哪一种通知机制，依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。</p>

<p>如果使用状态来通知，调用者需要每隔一定时间检查一次，效率比较低；如果使用通知或者回调的方式，效率相对高一些。</p>

<hr />

<h2>阻塞和非阻塞</h2>

<p>这两个概念与程序（线程）等待消息通知时的状态有关，主要是从程序（线程）等待消息通知时的状态角度来说的。</p>

<h3>阻塞</h3>

<p>调用结果返回之前，当前线程会被挂起，一直处理等待消息通知，不能够执行其他业务。函数只有在得到结果之后才会返回。</p>

<h3>非阻塞</h3>

<p>在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>

<p>虽然表面上看可以提高CPU利用率，但是带来的后果是系统的线程切换增加。增加的CPU执行时间能不能补偿系统的切换成本需要好好评估。</p>

<hr />

<h2>场景举例</h2>

<p>同步/异步关注的是消息通知的机制，而阻塞/非阻塞关注的是程序（线程）等待消息通知时的状态。</p>

<p>以下载文件举例：</p>

<h3>同步阻塞</h3>

<p>一直盯着下载进度条，到 100% 的时候就完成。</p>

<p>同步体现在：等待下载完成通知；</p>

<p>阻塞体现在：等待下载完成通知过程中，不能做其他任务处理；</p>

<h3>同步非阻塞</h3>

<p>提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到 100% 就完成。但是必须要在两个任务间切换，关注下载进度。</p>

<p>同步体现在：等待下载完成通知；</p>

<p>非阻塞体现在：等待下载完成通知过程中，去干别的任务了，只是时不时会瞄一眼进度条。</p>

<h3>异步阻塞</h3>

<p>换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过仍然一直等待“叮”的声音。</p>

<p>异步体现在：下载完成“叮”一声通知；</p>

<p>阻塞体现在：等待下载完成“叮”一声通知过程中，不能做其他任务处理；</p>

<h3>异步非阻塞</h3>

<p>仍然是那个会“叮”一声的下载软件，提交下载任务后就去干别的，听到“叮”的一声就知道完成了。</p>

<p>异步体现在：下载完成“叮”一声通知；</p>

<p>非阻塞体现在：等待下载完成“叮”一声通知过程中，去干别的任务了，只需要接收“叮”声通知即可。</p>

</body>
</html>

