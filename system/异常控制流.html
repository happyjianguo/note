<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>异常控制流</title>
	</head>
<body>
<h1>异常控制流</h1>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({tex2jax: {inlineMath:[['$','$']]}});
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<p>从给处理器加电开始，直到断电为止，程序计数器假设一个值的序列$a_0，a_1，…，a_(n-1)$，其中每个$a_k$是某个相应的指令$I_k$的地址。每次从$a_k$到$a_(k+1)$的过渡称为<strong>控制转移</strong>。这样的控制转移序列叫做处理器的<strong>控制流</strong>。</p>

<p>系统必须能够对系统状态的变化作出反应，现代系统通过使控制流发生突变来对这些情况作出反应，一般把这些突变称为<strong>异常控制流（Exceptional Control Flow，ECF）</strong>。</p>

<hr />

<h2>异常</h2>

<p><strong>异常就是控制流中的突变，用来响应处理器状态中的某些变化</strong>。</p>

<p>异常是ECF 的一种形式，它一部分是由硬件实现的，一部分是由操作系统实现的。</p>

<figure><img src="/Users/xerxes/note/system/src/%E5%BC%82%E5%B8%B8.png"/></figure>

<p>当处理器<strong>状态</strong>中发生一个重要的变化时，处理器正在执行某个当前指令I。在处理器中，状态被编码为不同的位和信号。状态变化称为<strong>事件</strong>。在任何情况下，处理器监测到有事件发生时，它就会通过一张叫做<strong>异常表</strong>的跳转表，进行一个间接过程调用，到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序）。</p>

<p>当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下三种情况的一种：</p>

<ul>
	<li>处理程序将控制返回给当前指令I，即当事件发生时正在执行的指令；</li>
	<li>处理程序将控制返回给如果没有发生异常将会执行的下一条指令；</li>
	<li>处理程序终止被中断的程序</li>
</ul>

<h3>异常处理</h3>

<p>系统中可能的每种类型的异常都分配了一个唯一的非负整数的<strong>异常号</strong>。其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核（操作系统常驻存储器的部分）的设计者分配的。</p>

<p>在系统启动时，操作系统分配和初始化一张<strong>异常表</strong>，它包含了所有异常的处理程序的地址。异常表的起始地址放在一个叫做<strong>异常表基址寄存器</strong>的特殊CPU 寄存器中。</p>

<h3>异常的类别</h3>

<figure><img src="/Users/xerxes/note/system/src/%E5%BC%82%E5%B8%B8%E7%9A%84%E7%B1%BB%E5%88%AB.png"/></figure>

<h4>中断</h4>

<p>中断是异步发生的，是来自处理器外部的I/O 设备的信号的结果。</p>

<p>硬件终端不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序通常称为<strong>中断处理程序</strong>。</p>

<figure><img src="/Users/xerxes/note/system/src/%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86.png"/></figure>

<p>如图，I/O 设备通过向处理器芯片上的一个引脚发信号，并将异常号放到系统总线上，以触发中断，这个异常号标识了引起中断的设备。</p>

<h4>陷阱和系统调用</h4>

<p>陷阱是有意的异常，是执行一条指令的结果。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做<strong>系统调用</strong>。</p>

<p>用户程序经常需要向内核请求服务，如读一个文件、创建一个新的进程、加载一个新的程序或是终止当前进程。为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的<code>syscall n</code>指令，当用户程序想要请求服务n 时，可以执行这条指令。执行这条指令会导致一个到异常处理程序的陷阱，这个处理程序对参数解码，并调用适当的内核程序。</p>

<figure><img src="/Users/xerxes/note/system/src/%E9%99%B7%E9%98%B1%E5%A4%84%E7%90%86.png"/></figure>

<h4>故障</h4>

<p>故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误，它就会控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的abort 例程，abort 例程会终止引起故障的应用程序。</p>

<figure><img src="/Users/xerxes/note/system/src/%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86.png"/></figure>

<h4>终止</h4>

<p>终止是不可恢复的错误造成的结果，通常是一些硬件错误。终止处理程序从不将控制返回给应用程序。</p>

<figure><img src="/Users/xerxes/note/system/src/%E7%BB%88%E6%AD%A2%E5%A4%84%E7%90%86.png"/></figure>

<hr />

<h2>进程</h2>

<p><strong>进程就是一个执行中的程序的实例。系统中的每个程序都是运行在该进程的上下文中的，CPU 会在各个进程之间进行来回切换</strong>。</p>

<p>进程提供给了应用程序两个关键抽象：</p>

<ul>
	<li>一个独立的<strong>逻辑控制流</strong>：它提供一个假象，好像程序独占地使用处理器；</li>
	<li>一个私有的<strong>地址空间</strong>：它提供一个假象，好像程序独占地使用存储器系统</li>
</ul>

<h3>逻辑控制流</h3>

<p>即使在系统中通常有许多其他程序在运行，进程也可以向每个程序提供一种假象，好像它在独占地使用处理器。</p>

<p>如果想用调试器单步执行程序，会看到一系列的程序计数器的值，这些值唯一的对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令。这个<strong>程序计数器的值的序列称为逻辑控制流</strong>。</p>

<p>进程是轮流使用处理器的，每个进程执行它的流的一部分，然后被挂起，轮到其他进程。对于一个运行在这些进程之一的上下文中的程序，看上去就像在独占的使用处理器。</p>

<h3>并发流</h3>

<p>计算机系统中逻辑流有许多不同的形式。异常处理程序、进程、信号处理程序、线程和Java 进程都是逻辑流的例子。</p>

<p><strong>一个逻辑流的执行在时间上与另一个流重叠，称为并发流（concurrent flow），这两个流称为并发运行</strong>。</p>

<p>多个流并发地执行的现象称为<strong>并发（concurrency）</strong>，一个进程和其他进程轮流运行的概念称为<strong>多任务（multitasking）</strong>，一个进程执行它的控制流的一部分的时间段叫做<strong>时间片（time slice）</strong>。因此，多任务也叫做<strong>时间分片</strong>。</p>

<h3>私有地址空间</h3>

<p>进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。</p>

<p>一个进程为每个程序提供它自己的<strong>私有地址空间</strong>，一般来说，和这个空间中某个地址相关联的那个存储器字节是不能被其他进程读或者写的，也就是说这个地址空间是私有的。</p>

<h3>用户模式和内核模式</h3>

<p><strong>处理器提供了一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围</strong>。</p>

<p>处理器通常是用某个<strong>控制寄存器中的一个模式位（mode bit）来提供这种功能的，该寄存器描述了进程当前享有的特权</strong>。</p>

<p>当设置了模式位时，进程就运行在<strong>内核模式</strong>中（有时叫做超级用户模式）。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中任何存储器位置。</p>

<p>没有设置模式位，进程就运行在<strong>用户模式</strong>中。用户模式中的进程不允许执行特权指令（privileged instruction），如停止处理器、改变模式位，或者发起一个I/O 操作。也不允许用户模式中的进程直接引用地址空间中内核区的代码和数据。用户程序必须通过系统调用接口间接的访问内核代码和数据。</p>

<p><strong>运行应用程序代码的进程初始化时是在用户模式中，进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常</strong>。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式，处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式改回到用户模式。</p>

<h3>上下文切换</h3>

<p>操作系统内核是用一种称为<strong>上下文切换</strong>的较高层形式的异常控制流来实现多任务。</p>

<p>内核为每个进程维护一个<strong>上下文，上下文就是内核重新启动一个挂起的进程所需的状态</strong>。它由一些对象的值组成，这些对象包括<strong>通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描绘地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表</strong>。</p>

<p><strong>进程表（process table）中每一项是一个进程</strong>，项中包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动。</p>

<figure><img src="/Users/xerxes/note/system/src/%E5%85%B8%E5%9E%8B%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%A1%A8%E9%A1%B9%E7%9A%84%E6%95%B0%E6%8D%AE.png"/></figure>

<p>如上图是一个典型的进程表表项中的一些字段。</p>

<p>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程。这种决定称为<strong>调度</strong>，是由内核中称为<strong>调度器</strong>的代码处理的。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用上下文切换的机制来控制转移到新的进程，上下文切换会做几件事情：</p>

<ol>
	<li>保存当前进程的上下文；</li>
	<li>恢复某个先前被挂起的进程的上下文；</li>
	<li>将控制传递给这个新恢复的进程</li>
</ol>

<figure><img src="/Users/xerxes/note/system/src/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2.png"/></figure>

<p>如上图展示了一对进程A 和B 之间上下文切换的示例。初始地，进程A 运行在用户模式下，直到它通过执行系统调用read 陷入到内核。内核中的陷阱处理程序请求来自磁盘控制器的DMA 传输，并且安排在磁盘控制器完成从磁盘到存储器的数据传输后，磁盘中断处理器。</p>

<hr />

<h2>进程控制</h2>

<h3>获取进程ID</h3>

<p>每个进程都有一个唯一的正数非零进程ID（PID）。</p>

<h3>进程的状态</h3>

<p>从程序员角度，可以认为进程总是处于三种状态之一：</p>

<ul>
	<li>运行：进程要么在CPU 上执行，要么在等待被执行且最终会被内核调度；</li>
	<li>停止：进程的执行被挂起，且不会被调度。当收到SIGSTOP、SIGTSTP、SIDTTIN 或者SIGTTOU 信号时，进程就停止，直到收到一个SIGCONT 信号，进程再次开始运行；</li>
	<li>终止：进程永远停止。进程会因为三种原因终止：

		<ul>
			<li>收到一个信号，该信号的默认行为是终止进程；</li>
			<li>从主程序返回；</li>
			<li>调用exit 函数</li>
		</ul></li>
</ul>

<p>当一个进程开始运行时，它可能会经历如下图几种状态：</p>

<figure><img src="/Users/xerxes/note/system/src/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.png"/></figure>

<ul>
	<li>运行态：运行态指的是进程实际占用CPU 时间片运行时；</li>
	<li>就绪态：就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态，获得不到CPU 时间分片；</li>
	<li>阻塞态：除非某种外部事件发生，否则进程不能运行，CPU 空闲时也不能运行</li>
</ul>

<p>三种状态会涉及四种状态间的切换，转换2、3都是由进程调度程序（操作系统的一部分）引起的，进程本身不知道它的存在。转换2的出现说明进程调度器认为当前进程已经运行了足够长的时间，该其他进程运行CPU 时间片了。当所有其他进程都运行过后，让第一个进程重新获得CPU 时间片时就会发生转换3。</p>

<p>当进程等待的一个外部事件（如等待数据）发生时，则发生转换4。如果此时没有其他进程在运行，则立刻触发转换3；否则处于就绪状态，等待CPU 空闲。</p>

<p><strong>程序调度指的是决定哪个进程优先被运行和运行多久</strong>。</p>

<h3>创建进程</h3>

<p>父进程通过调用fork 函数创建一个新的运行子进程，子进程几乎但不完全与父进程相同。<strong>子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份拷贝，还获得与父进程任何打开文件描述符相同的拷贝</strong>，这就意味着当父进程调用fork 时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。</p>

<figure><img src="/Users/xerxes/note/system/src/fork%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%A4%BA%E4%BE%8B.png"/></figure>

<p>如图展示了一个使用fork 创建子进程的代码示例，这个示例说明了几点：</p>

<ul>
	<li>调用一次，返回两次：Fork 函数调用一次会返回两次，一次是在父进程中返回子进程的PID，一次是在子进程中返回0；</li>
	<li>并发执行：父进程和子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令；</li>
	<li>相同但独立的地址空间：如果能够在fork 函数在父进程和子进程中返回后立即暂停两个进程，就可以看到每个进程的地址空间都是相同的。然而因为父进程和子进程都是独立的进程，它们都有自己的私有地址空间；</li>
	<li>共享文件：子进程会继承父进程所有打开文件</li>
</ul>

<h3>进程的终止</h3>

<p>进程的终止通常由于以下情况触发：</p>

<ul>
	<li>正常退出：当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用（UNIX 中是<code>exit</code>）告诉操作系统它完成了工作</li>
	<li>错误退出</li>
	<li>严重错误：通常由于程序中的错误导致。UNIX 中进程可以通知操作系统，它希望自行处理某种类型的错误，这类错误发生时，进程会收到信号（中断），而不是在这类错误出现时直接终止进程</li>
	<li>被其他进程杀死：某个进程执行系统调用UNIX 中是<code>kill</code>告诉操作系统杀死某个进程</li>
</ul>

<h3>回收子进程</h3>

<p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从此时开始，该进程就不存在了。</p>

<p>一个终止了但还未被回收的进程被称为<strong>僵死进程（zombie）</strong>。</p>

<p>如果父进程没有回收它的子进程就终止了，那么内核就会安排init 进程来回收它们。init 进程的PID 为1，并且是在系统初始化时由内核创建的。</p>

<p>一个进程可以通过调用waitpid 函数来等待它的子进程终止或者停止。默认地，waitpid 挂起调用进程的执行，直到它的等待集合中的一个子进程终止。</p>

<h3>让进程休眠</h3>

<p>Sleep 函数将一个进程挂起一段指定的时间。</p>

<p>如果请求的时间到了，sleep 返回0，如果因为sleep 函数被一个信号中断而过早返回，则返回还剩下的要休眠的秒数。</p>

<p>Pause 函数让调用函数休眠，直到该进程收到一个信号。</p>

<h3>加载并运行程序</h3>

<p>execve 函数在当前进程的上下文中加载并运行一个新程序。</p>

<hr />

<h2>线程</h2>

<p>多线程之间会共享同一块地址空间和所有可用数据的能力，这是进程所不具备的。</p>

<p>线程要比进程更轻量级，由于线程更轻，所有它比进程更容易创建，也更容易撤销。</p>

<p>计算密集型和I/O 密集型情况下，多线程能在这些活动中彼此重叠进行，从而加快应用程序的执行速度。</p>

<h3>多线程解决方案</h3>

<hr />

<h2>信号</h2>

<p>Unix 信号，是一种更高层的软件形式的异常，它允许进程中断其他进程。</p>

<p>每种信号类型都对应于某种系统事件。底层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。</p>

<h3>信号概念</h3>

<p>传送一个信号到目的进程有两步：</p>

<ul>
	<li>发送信号：内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。发送信号可以有两个原因：1. 内核监测到一个系统事件，比如被零除错误或者子进程终止；2. 一个进程调用了kill 函数，显式地要求内核发送一个信号给目的进程；</li>
	<li>接收信号：当目的进程被内核强迫以某种方式对信号的发送作出反应时，目的进程就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序的用户层函数捕获这个信号</li>
</ul>

<p>一个只发出而没有被接收的信号叫做<strong>待处理信号</strong>，任何时刻一个进程至多只会有一种类型的信号。</p>

<h3>发送信号</h3>

<p>Unix 系统提供了大量向进程发送信号的机制，所有这些机制都是基于<strong>进程组（process group）</strong>这个概念的。</p>

<h4>进程组</h4>

<p>每个进程都只属于一个进程组，进程组是由一个正整数进程组ID 来标识的。</p>

<h4>用<code>/bin/kill</code>程序发送信号</h4>

<p><code>/bin/kill</code>程序可以向另外的进程发送任意的信号：</p>

<p><code>/bin/kill -9 PID</code></p>

<h4>从键盘发送信号</h4>

<p>Unix shell 使用job 这个抽象概念来表示对一个命令行求值而创建的进程。</p>

<p><code>ls | sort</code></p>

<p>创建一个由两个进程组成的job，这两个进程是通过Unix 管道连接起来的。</p>

<p>Shell 为每个job 创建一个独立的进程组。典型地，进程组ID 取自作业中父进程中的一个。如图：<img src="/Users/xerxes/note/system/src/%E4%BD%9C%E4%B8%9A%E7%BB%84.png"/></p>

<p>在键盘上输入ctrl-c 会导致一个SIGINT 信号发送到shell。shell 捕获到该信号，然后发送SIGINT 信号到前台进程组中的每个进程。</p>

<h3>接收信号</h3>

<p>当内核从一个异常处理程序返回，准备将控制传递给进程p 时，它会检查进程p 的未被阻塞的待处理信号的集合。</p>

<p>如果这个集合为空，那么内核将控制传递到p 的逻辑控制流中的下一条指令。</p>

<p>如果集合非空，那么内核选择集合中的某个信号k（通常选最小的k），并且强制p 接收信号k。收到这个信号会触发进程的某种行为，进程完成这个行为后，控制就传递回p 的逻辑控制流的下一条指令。每个信号类型都有一个预定义的默认行为，有以下几种：</p>

<ul>
	<li>进程终止；</li>
	<li>进程终止并转出存储器；</li>
	<li>进程停止直到被SIGCONT 信号重启；</li>
	<li>进程忽略该信号</li>
</ul>

<h3>信号处理问题</h3>

<p>当一个程序要捕获多个信号时，会遇到一些问题：</p>

<ul>
	<li>待处理信号被阻塞：Unix 信号处理程序通常会阻塞当前处理程序正在处理的类型的待处理信号；</li>
	<li>待处理信号不会排队等待：任意类型至多只有一个待处理信号，因此如果有两个类型为k 的信号发送给同一进程，而进程当前正在执行信号k 的处理程序，所以信号k 时阻塞的，那么第二个信号就被丢弃了，不会排队等待；</li>
	<li>系统调用可以被中断：像read、wait 和accept 这样的系统调用潜在地会阻塞进程一段较长的时间，称为慢速系统调用。某些系统中当处理程序捕获到一个信号，被中断的慢速系统调用在信号处理程序返回时不再继续，而是立即返回给用户一个错误条件</li>
</ul>

</body>
</html>

