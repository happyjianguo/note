<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>并发编程</title>
	</head>
<body>
<h1>并发编程</h1>

<p>如果逻辑控制流在时间上重叠，那么它们就是并发的。</p>

<p>并发不仅可以看作是一种操作系统内核用来运行多个应用程序的机制，也常用在应用级上：</p>

<ul>
	<li>访问慢速I/O设备：当一个应用正在等待来自慢速I/O设备的数据到达时，内核会运行其他进程，使CPU保持繁忙。每个应用都可以按照类似的方式，通过交替执行I/O请求和其他有用的工作来使用并发</li>
	<li>与人交互：和计算机交互的人要求计算机有同时执行多个任务的能力，每次用户请求某种操作时，一个独立的并发逻辑流被创建来执行这个操作</li>
	<li>通过推迟工作以降低延迟：有时，应用程序能够通过推迟其他操作并且并发地执行它们，利用并发来降低某些操作的延迟。比如一个动态存储分配器可以通过推迟合并，把它放到一个运行在较低优先级上的并发“合并”流中，在 有空闲的CPU周期时充分利用这些空闲周期，从而降低单个free操作的延迟</li>
	<li>服务多个网络客户端：创建一个并发服务器，它为每个客户端创建一个单独的逻辑流。允许服务器同时为多个客户端服务，避免慢速客户端独占服务器</li>
	<li>在多核计算机上进行并行计算：许多现代系统都配备有多核处理器，多核处理器中包含多个CPU。被划分成并发流的应用程序通常在多核机器上比在单处理器上运行的快，因为这些流会并行执行</li>
</ul>

<p>使用应用级并发的应用程序称为<strong>并发程序</strong>。现代操作系统提供了三种基本的构造并发程序的方法：</p>

<ul>
	<li><strong>进程</strong>

		<p>用这种方法，每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显式的<strong>进程间通信（interprocess communication，IPC）机制</strong>；</p></li>
	<li><strong>I/O多路复用</strong>

		<p>在这种形式的并发编程中，应用程序在一个进程的上下文中显式地调用它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态。因为程序是一个单独的进程，所以所有的流都共享同一个地址空间；</p></li>
	<li><strong>线程</strong>

		<p>线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。可以把线程看成其他两种方式的混合体，像进程流一样由内核进行调度，而像I/O多路复用流一样共享同一个虚拟地址空间</p></li>
</ul>

<hr />

<h2>基于进程的并发编程</h2>

<p>构造并发程序最简单的方法就是使用进程。例如一个构造并发服务器的自然方法就是在父进程中接受客户端连接请求，然后创建一个新的子进程来为每个新客户端提供服务。</p>

<p>流程：</p>

<p>假设有两个客户端和一个服务器，服务器正在监听一个监听描述符3上的连接请求。</p>

<p>此时服务器接受了客户端1的连接请求，返回一个已连接描述符4。</p>

<p>接受连接请求后，服务器派生一个子进程，这个子进程获得服务器描述符表的完整拷贝。子进程关闭拷贝中的监听描述符3，父进程关闭已连接描述符4的拷贝。</p>

<h3>关于进程的优劣</h3>

<p>对于在父、子进程间共享状态信息，进程又一个非常清晰的模型：<strong>共享文件表，但是不共享用户地址空间</strong>。</p>

<p>进程有独立的地址空间既是优点也是缺点。一个进程不可能不小心覆盖另一个进程的虚拟存储器，但是独立的地址空间使得进程共享状态信息变得更加困难：为了共享信息，它们必须使用IPC机制。</p>

<hr />

<h2>基于I/O多路复用的并发编程</h2>

<p>假设开发一个echo 服务器，它必须响应两个互相独立的I/O 事件：</p>

<ul>
	<li>网络客户端发起连接请求；</li>
	<li>用户在键盘上输入命令行</li>
</ul>

<p>此时服务器不管等待哪个请求，都不能响应另外一个请求了。</p>

<p>解放方法就是<strong>I/O 多路复用（I/O multiplexing）技术</strong>。基本思路是使用select 函数，要求内核挂起进程，只有在一个或多个I/O 事件发生后，才将控制返回给应用程序。</p>

<hr />

<h2>基于线程的并发编程</h2>

<p>线程就是运行在进程上下文中的逻辑流。线程由内核自动调度。每个线程都有它自己的线程上下文，包括一个唯一的整数线程ID、栈、栈指针、程序计数器、通用目的寄存器和条件码。</p>

<p>所有的运行在一个进程中的线程共享该进程的整个虚拟地址空间。</p>

<h3>线程执行模型</h3>

<p>线程的上下文要比进程的上下文小的多，线程的上下文切换要比进程的上下文切换快得多。</p>

<p>线程不像进程那样按照严格的父子层次来组织。和一个进程相关的线程组成一个线程池，独立于其他进程创建的线程。</p>

</body>
</html>

