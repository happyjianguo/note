<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>CPU</title>
	</head>
<body>
<h1>CPU</h1>

<p>CPU 的核心是从程序或应用程序获取指令并执行计算。</p>

<p><strong>CPU 从系统的主存中提取指令，然后解码该指令的实际内容，然后再由CPU 的相关部分执行该指令</strong>。</p>

<p>下图展示了一般程序的运行流程：<img src="/Users/xerxes/note/system/src/%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.jpg"/></p>

<hr />

<h2>CPU 构成</h2>

<p>CPU 主要由两部分构成：</p>

<ul>
	<li>控制单元：从内存中提取指令并解码执行；</li>
	<li>算术逻辑单元（ALU）：处理算数和逻辑运算</li>
</ul>

<p>从功能上看，CPU 的内部由四部分组成：</p>

<ul>
	<li>寄存器：用来暂存指令、数据和地址；</li>
	<li>控制器：负责把内存上的指令、数据读入寄存器，并根据指令的结果控制计算机；</li>
	<li>运算器：负责运算从内存读入寄存器的数据；</li>
	<li>时钟：负责发出CPU 开始计时的时钟信号</li>
</ul>

<p>如图给出了一个详细一些的典型冯·诺伊曼结构CPU 的内部组成：<img src="/Users/xerxes/note/computerOrganization/src/CPU%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90.png"/></p>

<p>如图所示的部分称为<strong>数据通路</strong>， 包括<strong>寄存器（一般来说为1～32个）</strong>、<strong>算数逻辑部件（Arithmetic Logic Unit，ALU）</strong>和连接它们的内部总线。</p>

<p>寄存器给ALU 的两个输入寄存器提供输入，寄存器的功能是在ALU 进行计算时维持ALU 的输入。</p>

<p>ALU 对输入数据进行加、减等简单运算，然后将产生的运算结果送入输出寄存器，经输出寄存器存回某个寄存器。</p>

<p>大多数指令可以归并到下面两类当中：</p>

<ul>
	<li>寄存器 — 内存指令：用于寄存器和内存之间交换数据，例如将内存当中的字取到寄存器当中供后续指令使用。也可以将寄存器中的数据存回内存；</li>
	<li>寄存器 — 寄存器指令：通常从寄存器中取得两个操作数，送入ALU 的输入寄存器，对它们进行加法或逻辑与之类的运算，然后再将运算结果送回其中一个寄存器。ALU 将两个操作数进行运算并将结果存回的过程称为<strong>数据通路周期</strong>，是大多数CPU 的核心</li>
</ul>

<hr />

<h2>CPU 是一系列寄存器的集合体</h2>

<p>不同类型的CPU，其内部寄存器的种类、数量以及寄存器存储的数值范围都是不同的。根据功能的不同，可以将寄存器划分为以下几类：</p>

<ul>
	<li>累加寄存器：存储运行的数据和运算后的结果；</li>
	<li>标志寄存器：用于反应处理器的状态和运算结果的某些特征以及控制指令的执行；</li>
	<li>程序计数器：用于存放下一条指令所在单元的地址；</li>
	<li>基址寄存器：存储数据内存的起始位置；</li>
	<li>变址寄存器：存储基址寄存器的相对地址；</li>
	<li>通用寄存器：存储任意数据；</li>
	<li>指令寄存器：存储正在被运行的指令，CPU 内部使用，程序员无法对该寄存器进行读写；</li>
	<li>栈寄存器：存储栈区域的起始位置</li>
</ul>

<p>其中程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器只有一个，其他寄存器一般有多个。</p>

<h3>程序计数器（Program Counter）</h3>

<p><strong>用于存放下一条指令所在单元的地址，控制着程序的流程</strong>。</p>

<p>程序执行时，PC 的初始值为程序第一条指令的地址，在顺序执行程序时，控制器首先按程序计数器所指出的指令地址从内存中取出一条指令，然后分析并执行该指令，同时将PC 的值加一指向下一条要执行的指令。</p>

<figure><img src="/Users/xerxes/note/system/src/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.jpg"/></figure>

<p>如图是一段进行相加的操作，程序启动，经过编译解析后会由操作系统的硬盘中的程序复制到内存中，示例中的程序是将123和456相加，并将结果输出到显示器上。</p>

<h4>条件分支和循环控制</h4>

<p>高级语言中的条件控制流程主要有三种：</p>

<ul>
	<li>顺序执行：按照地址的内容顺序的执行指令；</li>
	<li>条件分支：根据条件执行任意地址的指令；</li>
	<li>循环：重复执行同一地址的指令</li>
</ul>

<h3>标志寄存器</h3>

<p>条件和循环控制会使用到jump（跳转指令），会根据当前的指令来判断是否跳转，无论当前累加寄存器的运算结果是正数、负数还是零，标志寄存器都会将其保存。</p>

<p>CPU 在进行运算时，标志寄存器的数值会根据当前运算的结果自动设定。</p>

<p>标志寄存器的第一个字节位、第二个字节位、第三个字节位各自的结果都为1时，分别代表正数、零和负数。</p>

<h4>函数调用机制</h4>

<p>函数调用处理是通过把程序计数器的值设定成函数的存储地址来实现的。</p>

<p>如下图是一个实现函数跳转的示例：<img src="/Users/xerxes/note/system/src/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B.jpg"/></p>

<p>函数的调用和返回很重要的两个指令是call 和return 指令，在将函数的入口地址设定到程序计数器之前，call 指令会把调用函数后要执行的指令地址存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行return 指令。return 指令的功能是把保存在栈中的地址设定到程序计数器。</p>

<figure><img src="/Users/xerxes/note/system/src/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.jpg"/></figure>

<h3>通过地址和索引实现数组</h3>

<p>通过<strong>基址寄存器</strong>和<strong>变址寄存器</strong>这两个寄存器，可以对主存上的特定区域进行划分，来实现类似数组的操作。</p>

<p>首先，用十六进制数将内存上的00000000 - FFFFFFFF 的地址划分出来。凡是该范围的内存地址，只要有一个32位的寄存器，便可查看全部地址。但如果想要像数组那样分割特定的内存区域以达到连续查看的目的，使用两个寄存器会更加方便。</p>

<p>例如使用两个寄存器（基址寄存器和变址寄存器）来表示内存的值。</p>

<hr />

<h2>CPU 指令执行过程</h2>

<p>几乎所有的冯·诺伊曼型计算机的CPU，其工作都可以分为五个阶段：</p>

<ul>
	<li><strong>取指令阶段</strong>：将内存中的指令读取到CPU 中寄存器；</li>
	<li><strong>指令译码阶段</strong>：在取指令完成后，立马进入指令译码阶段，在指令译码阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法；</li>
	<li><strong>执行指令阶段</strong>：译码完成后，就需要执行这一条指令了，此阶段的任务是完成指令所规定的各种操作，具体实现指令的功能；</li>
	<li><strong>访问取数阶段</strong>：根据指令的需要，有可能需要从内存中提取数据，此阶段的任务是：根据指令的地址码，得到操作数在主存中的地址，并从主存中读取该操作数用于运算；</li>
	<li><strong>结果写回阶段</strong>：把执行指令阶段的运行结果数据写回到某种存储形式，结果数据经常被写到CPU 的内部寄存器中，以便被后续的指令快速地存取</li>
</ul>

<hr />

<h2>cpu和load</h2>

<ol>
	<li>多⽤户多任务分时操作系统。分时操作系统是把CPU的时间划分成长短基本相同的时间区间,即”时间⽚”，通过操作系统的管理，把这些时间⽚依次轮流地分配给各个⽤户使⽤。 如果某个作业在时间⽚结束之前,整个任务还没有完成，那么该作业就被暂停下来,放弃CPU，等待下⼀轮循环再继续做.此时CPU又分配给另⼀个作业去使⽤。</li>
	<li>⽽我们说到的CPU的占⽤率，⼀般指的就是对时间⽚的占⽤情况。CPU利⽤率是对⼀个时间段内CPU使⽤状况的统计，通过这个指标可以看出在某⼀个时间段内CPU被占⽤的情况。</li>
	<li>CPU的Load是在⼀段时间内CPU正在处理以及等待CPU处理的进程数之和的统计信息，也就是CPU使⽤队列的长度的统计信息。</li>
	<li>有⼀个很好的⽐喻，就是把CPU的使⽤⽐喻成排队打电话：</li>
</ol>

<p>我们将CPU就类⽐为电话亭，每⼀个进程都是⼀个需要打电话的⼈。现在有⼀个电话亭（单核计算机），有10个⼈需要打电话（ 10个进程）。现在使⽤电话的规则是管理员会按照顺序给每⼀个⼈轮流分配1分钟的使⽤电话时间，如果使⽤者在1分钟内使⽤完毕，那么可以将电话使⽤权返还给管理员，如果到了1分钟电话使⽤者还没有使⽤完毕，那么需要重新排队，等待再次分配使⽤。在电话亭使⽤过程中，肯定会有⼈打完电话⾛掉，有⼈没有打完电话⽽选择重新排队，同样也会有新来的⼈继续排队，这个⼈数的变化就相当于任务数的增减。CPU的Load统计⼀定时间段内，所有使⽤电话的⼈加上等待电话分配的⼈数的平均值。为了统计平均负载情况，我们5分钟统计⼀次⼈数，并在第1、 5、 15分钟的时候对统计情况取平均值，从⽽形成第1、 5、 15分钟的平均负载。CPU利⽤率统计的进程在进⼊电话亭后，真正使⽤电话的时间和在电话亭停留的时间的⽐值。例如⼀个⽤户得到了⼀分钟的使⽤权，在10秒钟内打了电话，然后去查询号码本花了20秒钟，再⽤剩下的30秒打了另⼀个电话。那么他的利⽤率就是(10+30)/60</p>

<ol>
	<li>虚拟内存：进程能访问的内存⼤⼩。</li>
	<li>逻辑地址： cpu拿到的地址。</li>
	<li>线性地址（虚拟地址）：进程使⽤的地址。对于每个独⽴的进程来说，虚拟地址分为内核空间和⽤户空间。</li>
	<li>地址转换：内存管理单元</li>
	<li>逻辑地址 ---》 ·分段单元· ---》 线性地址 ---》 ·分⻚单元· ---》 物理地址</li>
</ol>

</body>
</html>

