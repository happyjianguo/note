<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>计算机系统概览</title>
	</head>
<body>
<h1>计算机系统概览</h1>

<p>计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。</p>

<p>任何计算机系统都包含一个名为操作系统的基本程序集合。在这个集合中，最重要的程序称为<strong>内核（kernel）</strong>。</p>

<p>当操作系统启动时，内核被装入到RAM 中，内核中包含了系统运行必不可少的很多核心过程。</p>

<p>操作系统必须完成两个主要目标：</p>

<ul>
	<li>与硬件部分交互，为包含在硬件平台上的所有低层可编程部件提供服务；</li>
	<li>为运行在计算机系统上的应用程序提供执行环境</li>
</ul>

<hr />

<h2>信息就是：位 + 上下文</h2>

<p>系统中所有的信息：包括磁盘文件、存储器中的程序、存储器中存放的用户数据以及网络上传送的数据，都是由一串“位”表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。</p>

<p>源程序实际上就是一个由值0和1组成的位序列，8个位组成一组，成为字节。每个字节表示程序中某个文本字符。</p>

<p>大部分现代系统都使用ASCII标准来表示文本字符，这种方式实际上就是用一个唯一的单字节大小的整数值来表示每个字符。</p>

<hr />

<h2>程序被其他程序翻译成不同的格式</h2>

<p>为了在系统上运行程序，程序中的每条语句都必须被其他程序转化为一系列的<em>低级机器语言指令</em>。然后这些指令按照一种称为<em>可执行目标程序</em>的格式打好包，并以<em>二进制磁盘文件</em>的形式存放起来。</p>

<p>一个源程序文件由编译器驱动程序翻译成一个可执行目标文件的过程可分为四个阶段：</p>

<ul>
	<li>预处理阶段：预处理器（cpp）根据以字符#开头的命令，修改原始的C 程序，通常以.i 作为文件扩展名；</li>
	<li>编译阶段：编译器（ccl）将文本文件.i 翻译成文本文件.s，它包含一个汇编语言程序。汇编语言程序中的每条语句都以一种标准的文本格式确切地描述了一条低级机器语言指令；</li>
	<li>汇编阶段：汇编器（as）将.s 翻译成机器语言指令，把这些指令打包成一种叫做<em>可重定向目标程序（relocatable object program）</em>的格式，并将结果保存在目标文件.o 中。.o 文件是一个二进制文件，它的字节编码是机器语言指令而不是字符；</li>
	<li>链接阶段：当程序调用了printf 函数，它是每个C 编译器都会提供的标准C 库中的一个函数。printf 函数存在于一个名为printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到程序中。链接器（ld）就负责这种合并。最终得到的文件，是一个<em>可执行目标文件</em>，可以被加载到内存中，由系统执行。</li>
</ul>

<p><strong>执行这四个阶段的程序：预处理器、编译器、汇编器和链接器，一起构成了编译系统</strong>。</p>

<hr />

<h2>了解编译系统的好处</h2>

<h3>优化程序性能</h3>

<p>现代编译器都是成熟的工具，通常可以生成很好的代码。但是为了在程序中作出好的编码选择，需要了解一些机器代码以及编译器将不同程序语句转化为机器代码的方式。</p>

<p>如一个switch 语句是否总是比一系列的if-then-else 语句更高效？一个函数调用的开销有多大？</p>

<h3>理解链接时出现的错误</h3>

<p>一些最令人困扰的程序错误往往都与链接器操作有关，尤其是试图构建大型的软件系统时。</p>

<p>例如链接器报告它无法解析一个引用是什么意思？静态变量和全局变量的区别是什么？</p>

<h3>避免安全漏洞</h3>

<p>多年来，缓冲区溢出错误是造成大多数网络和Internet 服务器上安全漏洞的主要原因。</p>

<p>存在这些错误是因为很少有人能理解限制它们从不受信任和站点接收数据的数量和格式的重要性。学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。</p>

<hr />

<h2>处理器读并解释存储在存储器中的指令</h2>

<h3>系统硬件组成</h3>

<p>如下图所示是一个典型系统的硬件组成：</p>

<figure><img src="/Users/xerxes/note/system/src/%E5%85%B8%E5%9E%8B%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.jpg"/></figure>

<h4>总线</h4>

<p>贯穿整个系统的是一组电子管道，称为总线。</p>

<p>它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字。字中字节数（即字长）是一个基本的系统参数。</p>

<h4>I/O 设备</h4>

<p>输入/输出（I/O）设备是系统与外部世界的联系通道。</p>

<p>每个I/O 设备都通过一个控制器或适配器与I/O 总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是置于I/O 设备本身的或者系统的主印制电路板（主板）上的芯片组；适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在I/O 总线和I/O 设备之间传递信息。</p>

<h4>主存</h4>

<p>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。</p>

<h4>处理器</h4>

<p>中央处理单元，即CPU，是解释（或执行）存储在主存中指令的引擎。</p>

<hr />

<h2>高速缓存至关重要</h2>

<p>程序的机器指令最初存放在磁盘上，当程序加载时，它们被复制到主存；当处理器运行程序时，指令又从主存复制到处理器。系统花费了大量的时间把信息从一个地方传到另一个地方。</p>

<p>针对处理器与主存之间的差异，系统设计者采用了更小、更快的存储设备，即高速缓存存储器（高速缓存），作为暂时的集结区域，用来存放处理器近期可能会需要的信息。</p>

<figure><img src="/Users/xerxes/note/system/src/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8.jpg"/></figure>

<p>位于处理器芯片上的L1高速缓存的容量可达数万字节，访问速度几乎和访问寄存器文件一样快。一个容量为数十万字节的更大的L2高速缓存通过一条特殊的总线连接到处理器。进程访问L2高速缓存的时间要比访问L1高速缓存的时间长5倍，但是这仍然比访问主存的时间快5-10倍。</p>

<p>L1和L2高速缓存是用一种叫做<strong>静态随机访问存储器（SRAM）</strong>的硬件技术实现的。</p>

<p>比较新的、处理能力更强大的系统甚至有三级高速缓存：L1、L2和L3。<strong>系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势</strong>。</p>

<hr />

<h2>操作系统管理硬件</h2>

<p>操作系统可以看作是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作都必须通过操作系统。</p>

<figure><img src="/Users/xerxes/note/system/src/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.jpg"/></figure>

<p>操作系统有两个基本功能：</p>

<ul>
	<li>防止硬件被失控的应用程序滥用；</li>
	<li>向应用程序提供简单一致的机制来控制复杂而又通常大相径庭的低级硬件设备</li>
</ul>

<p>操作系统通过几个基本的抽象概念（进程、虚拟存储器和文件）来实现这两个功能。</p>

<figure><img src="/Users/xerxes/note/system/src/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E6%8A%BD%E8%B1%A1%E8%A1%A8%E7%A4%BA.jpg"/></figure>

<p>文件是对I/O 设备的抽象表示，虚拟存储器是对主存和磁盘I/O 设备的抽象表示，进程则是对处理器、主存和I/O 设备的抽象表示。</p>

<h3>进程</h3>

<p>进程是操作系统对一个正在运行的程序的一种抽象。</p>

<p>在一个系统上可以同时运行多个进程，每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。</p>

<p>在大多数系统中，需要运行的进程数是多于可以运行它们的CPU 个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个CPU 看上去都像是在并发地执行多个进程。这是通过处理器在进程间切换来实现的，操作系统实现这种交错执行的机制称为<strong>上下文切换</strong>。</p>

<h3>线程</h3>

<p>在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成。</p>

<p>每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。</p>

<p>由于网络服务器对并行处理的需求，线程称为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。</p>

<h3>虚拟存储器</h3>

<p>虚拟存储器是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的是一致的存储器，称为<strong>虚拟地址空间</strong>。</p>

<figure><img src="/Users/xerxes/note/system/src/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png"/></figure>

<p>如上图是Linux 系统进程的虚拟地址空间。在Linux 中，地址空间最上面的区域是为操作系统中的代码和数据保留的，这对所有进程来说都是一样的。地址空间的底部区域存放用户进程定义的代码和数据。</p>

<p>每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。</p>

<h4>程序代码和数据</h4>

<p>对于所有的进程来说，代码是从同一固定地址开始，紧接着的是和C 全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件hello。</p>

<h4>堆</h4>

<p>代码和数据区后紧接着是运行时堆。</p>

<p>代码和数据区是在进程已开始运行时就被规定了大小，与此不同，当调用malloc 和free 这样的C 标准库函数时，堆可以在运行时动态地扩展和收缩。</p>

<h4>共享库</h4>

<p>大约在地址空间的中间部分是一块用来存放像C 标准库和数学库这样共享库的代码和数据的区域。</p>

<h4>栈</h4>

<p>位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。</p>

<p>和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别是每次调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。</p>

<h4>内核虚拟存储器</h4>

<p>内核总是驻留在内存中，是操作系统的一部分。</p>

<p>地址空间顶部的区域是为内核保留的，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。</p>

<h3>文件</h3>

<p>文件就是字节序列。</p>

<p>每个I/O 设备，包括磁盘、键盘、显示器，甚至网络，都可以视为文件。系统中的所有输入输出都是通过使用一小组称为Unix I/O 的系统函数调用读写文件来实现的。</p>

<hr />

<h2>系统间网络通信</h2>

<p>从一个单独的系统来看，网络可视为一个I/O 设备。</p>

<figure><img src="/Users/xerxes/note/system/src/%E5%B0%86%E7%BD%91%E7%BB%9C%E7%9C%8B%E4%BD%9CI:O%E8%AE%BE%E5%A4%87.png"/></figure>

<p>当系统从主存将一串字节复制到网络适配器时，数据流经过网络到达另一台机器。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。</p>

<hr />

<h2>重要主题</h2>

<h3>并发和并行</h3>

<p>并发（concurrency）是一个通用的概念，指一个同时具有多个活动的系统。</p>

<p>并行（parallelism）指的是用并发使一个系统运行的更快。</p>

<p>并行可以在计算机系统的多个抽象层次上运行。</p>

<h4>线程级并发</h4>

<p>构建进程这个抽象，能够设计出同时执行多个程序的系统，这就导致了并发。使用线程，甚至能够在一个进程中执行多个控制流。</p>

<p>从20世纪60年代初期出现时间共享以来，计算机系统中就开始有了对并发执行的支持。传统意义上，这种并发只是模拟出来的，是通过在正在执行的进程间快速切换的方式实现的。</p>

<p>在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的，这种配置称为<strong>单处理器系统</strong>。</p>

<p>当构建一个由单操作系统内核控制的多处理器组成的系统时，就得到了一个<strong>多处理器系统</strong>。从20世纪80年代开始，在大规模的计算中就采用了这种系统，直到后来随着<strong>多核处理器和超线程</strong>的出现，这种系统才变得常见。</p>

<p><strong>多核处理器是将多个CPU 集成到一个集成电路芯片上</strong>。</p>

<p><strong>超线程，有时称为同时多线程（simultaneous multi-threading），是一项允许一个CPU 执行多个控制流的技术</strong>。</p>

<p>它涉及CPU 某些硬件有多个备份，比如程序计数器和寄存器文件；而其他的硬件备份只有一份，比如执行浮点算术运算的单元。常规的处理器需要大约20000个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得CPU 能够更好地利用它的处理资源。</p>

<p>例如，假设一个线程必须等到某些数据被装载到高速缓存中，那CPU 就可以继续去执行另一个线程。</p>

<h4>指令级并行</h4>

<p><strong>在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行</strong>。</p>

<p>早起的微处理器，需要多个时钟周期（通常3-10个）来执行一条指令。比较先进的处理器可以保持每个时钟周期2-4条指令的执行速率。</p>

<p>其实每条指令从开始到结束需要长的多的时间，大约20个或更多的周期，但是处理器使用了非常多的聪明技巧来同时处理多达100条的指令。</p>

<p>例如在流水线中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。</p>

<h4>单指令、多数据并行</h4>

<p>在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD 并行。</p>

<h3>抽象</h3>

<p>抽象的使用是计算机科学中最为重要的概念之一。</p>

<figure><img src="/Users/xerxes/note/system/src/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%BD%E8%B1%A1.png"/></figure>

<p>在处理器中，指令集结构提供了对实际处理器硬件的抽象。使用这个抽象，机器代码程序表现的就好像它是运行在一个一次只执行一条指令的处理器上。</p>

</body>
</html>

