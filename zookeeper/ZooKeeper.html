<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>ZooKeeper</title>
	</head>
<body>
<h1>ZooKeeper</h1>

<p>ZooKeeper时Yahoo开发并开源出的一套可扩展高吞吐分布式协调系统，可以很方便地解决各种分布式系统的管理协调问题。</p>

<hr />

<h2>分布式一致性特性</h2>

<p>Zk可以保证如下分布式一致性特性：</p>

<ul>
	<li>顺序一致性

		<p>从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到zk中去。</p></li>
	<li>原子性

		<p>所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说要么整个集群所有机器都成功应用了某一个事务，要么都没有应用。</p></li>
	<li>单一视图

		<p>无论客户端连接的是集群中哪一台机器，看到的服务端数据模型都是一样的。</p></li>
	<li>可靠性

		<p>一旦服务端成功应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会一直保留下来，除非有另一个事务又对其进行了变更。</p></li>
	<li>实时性

		<p>zk仅仅保证一定时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。</p></li>
</ul>

<hr />

<h2>设计目标</h2>

<h3>简单的数据模型</h3>

<p>Zk使分布式系统能够通过一个共享的、树形结构的namespace来进行相互协调。</p>

<p>Namespace是指zk服务器内存中的一个数据模型，其由一系列被称为ZNode的数据节点组成。所有ZNode按层次化结构进行组织，形成一棵树。</p>

<p>ZNode的节点路径标识方式由一系列使用斜杠“/”进行分割的路径表示，节点可以写入数据，也可以在节点下面创建子节点。</p>

<h3>可以构建集群</h3>

<p>一个zk集群由一组机器组成。集群中每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都互相保持通信。只要集群中超过半数的机器能够正常工作，整个集群就能正常提供服务。</p>

<h3>顺序访问</h3>

<p>对于来自客户端的每个更新请求，zk都会分配一个全局唯一的递增序号，用来反映所有事务操作的先后顺序。</p>

<h3>高性能</h3>

<p>由于zk将全量数据存储在内存中，并直接服务于客户端的所有非事务请求，因此zk尤其适用于以读操作为主的应用场景。</p>

<hr />

<h2>基本概念</h2>

<h3>集群角色</h3>

<h3>会话</h3>

<p>在zk中，一个客户端连接是指客户端和服务器之间的一个TCP长连接。</p>

<p>客户端启动时，首先会与服务器建立一个TCP连接，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向zk服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。</p>

<p>Session的sessionTimeout用来设置一个session的超时时间，当客户端连接断开时，只要在sessionTimeout规定的时间内能够重新连接上集群任意一台服务器，之间的session依然有效。</p>

<h3>数据节点</h3>

<p>在zk中，有两种节点，一个是构成集群的机器，称为机器节点；一个是数据模型中的数据单元，称为数据节点：ZNode。</p>

<p>Zk将所有数据存储在内存中，数据模型类似树形结构，由“/”分割的路径就是一个ZNode。</p>

<h4>节点类型</h4>

<p>ZNode分为<strong>持久节点</strong>和<strong>临时节点</strong>：</p>

<ul>
	<li>持久节点

		<p>一旦被创建，除非主动进行移除，否则将一直保存在zk中</p></li>
	<li>临时节点

		<p>生命周期和session绑定，一旦session失效，临时节点自动被移除</p></li>
</ul>

<p>Zk还允许用户为每个节点添加一个属性<strong>SEQUENTIAL</strong>，有此属性的节点在被创建时，zk自动在其节点名后面追加一个由父节点维护的整形自增数字，用来记录每个子节点创建的先后顺序。</p>

<h4>状态信息</h4>

<p>每个ZNode保存自己的数据内容，同时还会保存一系列状态信息，状态信息保存在当前数据节点的Stat中。</p>

<figure><img src="/Users/xerxes/note/zookeeper/src/zk%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF.jpg"/></figure>

<h3>版本</h3>

<p>数据节点的Stat中记录了这个ZNode的三个数据版本：</p>

<ul>
	<li>version：当前ZNode的版本</li>
	<li>cversion：当前ZNode子节点的版本</li>
	<li>aversion：当前ZNode的ACL版本</li>
</ul>

<p>Zk中的版本表示的是对数据节点的数据内容、子节点列表，或是节点ACL信息的修改次数。</p>

<p>以version为例，在一个数据节点被创建完成之后，节点的version值是0，表示“当前节点被创建之后，被更新过0次”。</p>

<h3>Watcher</h3>

<p>事件监听器，是zk一个很重要的特性。</p>

<p><strong>Zk允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，zk服务端会将事件通知到感兴趣的客户端上</strong>，该机制是zk实现分布式协调系统的重要特性。</p>

<h4>工作机制</h4>

<p>zk的Watcher机制分为三个过程：客户端注册Watcher、服务端处理Watcher和客户端回调Watcher。</p>

<h4>Watcher特性</h4>

<h5>一次性</h5>

<p>无论是服务端还是客户端，一旦一个Watcher被触发，zk都会将其从相应的存储中移除。</p>

<h5>客户端串行执行</h5>

<p>客户端Watcher回调的过程是一个串行同步的过程，这点保证了顺序。</p>

<h5>轻量</h5>

<p>WatchedEvent是zk整个Watcher通知机制的最小通知单元，这个数据结构中只包含三部分内容：通知状态、时间类型和节点路径。</p>

<p>也就是说，Watcher通知时只会告诉客户端发生了事件，而不会说明发生了什么事件。</p>

<p>客户端向服务端注册Watcher的时候，并不会把客户端真实的Watcher对象传递到服务端，仅仅只是在客户端请求中使用boolean类型属性进行了标记，服务端也只是保存了当前连接的ServerCnxn对象。</p>

<h3>ACL</h3>

<p>Zk采用ACK（Access Control Lists）策略来进行权限控制，类似于UNIX文件系统的权限控制。zk定义了五种权限：</p>

<ul>
	<li>create：创建子节点的权限</li>
	<li>read：获取节点数据和子节点列表的权限</li>
	<li>write：更新节点数据的权限</li>
	<li>delete：删除子节点的权限</li>
	<li>admin：设置节点ACL的权限</li>
</ul>

<hr />

<h2>服务器角色</h2>

<h3>Leader</h3>

<p>整个集群工作机制中的核心，主要负责：</p>

<ul>
	<li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性；</li>
	<li>集群内部内部各服务器的调度着</li>
</ul>

<h3>Follower</h3>

<p>主要负责：</p>

<ul>
	<li>处理客户端非事务请求，转发事务请求给Leader；</li>
	<li>参与事务请求Proposal的投票；</li>
	<li>参与Leader选举投票</li>
</ul>

<h3>Observer</h3>

<p>Zk3.3.0版本引入的全新的服务器角色，充当观察者角色，观察zk集群的最新状态变化并将这些状态变更同步过来。</p>

<p>工作原理和Follower基本一致，对于非事务请求可以进行独立的处理，对于事务请求转发给Leader。</p>

<p>和Follower的区别是，Observer不参与任何形式的投票。</p>

<hr />

<h2>读写流程</h2>

<p>ZooKeeper服务由若干台服务器构成，每台服务器内存中维护相同的类似于文件系统的树形结构。其中的一台通过ZAB原子广播协议选举作为主控服务器，其他的作为从属服务器。</p>

<p>客户端通过TCP协议连接任意一台服务器，如果客户端是读操作请求，则任意一个服务器都可以直接响应请求；如果是写操作，则只能由主控服务器来协调完成。</p>

<figure><img src="/Users/xerxes/note/zookeeper/src/zk%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg"/></figure>

<h3>写操作流程</h3>

<p>主控服务器将所有写操作序列化（客户端通过TCP协议连接，所以可以保证客户端请求的顺序性，同时系统内所有写操作都需要经过主控服务器，这两点可以保证写操作的全局序列性），利用ZAB协议将数据更新请求通知所有从属服务器，ZAB保证更新操作的一致性和顺序性。</p>

<p>顺序性指的是从属服务器的数据更新顺序和主控服务器的更新顺序是一样的。这个一致性协议采用简单的多数投票仲裁（Majority Quorums）方式，这意味着只有多数投票服务器存活，ZooKeeper才能正常运行。</p>

<p>如果多数从属服务器向主控服务器确认更新成功，则可以通知客户端本次更新操作成功。</p>

<h3>读操作流程</h3>

<p>ZooKeeper的任意一台服务器都可以响应客户端的读操作，这是为何其吞吐量高的主要原因。</p>

<p>当主控服务器已经更新了某个内存数据，但是ZAB协议还未能将其广播到从属服务器，客户端就可能读到过期数据。因此zk在接口API中提供了Sync操作，应用可以根据需要在读数据前调用该操作，接收到Sync命令的从属服务器从主控服务器同步状态信息，保证两者完全一致。</p>

<p>服务器在响应读/写请求时，都会返回客户端一个渐增的zxid编号，客户端在后续请求中会将这个zxid附带在读/写请求中，这个编号代表了这个服务器目前所见到的更新操作的最高编号。如果一个客户端从某个服务器切换连接到另一台服务器，新服务器会通过比较客户端发送的zxid和服务器本身的zxid，来保证给这个客户端看到的数据版本不会比之前的服务器的数据版本更低。如果客户端请求zxid编号高于服务器本身最高zxid，则其从主控服务器同步内存数据到最新状态，然后再响应读操作。</p>

<p>Zk通过<strong>重放日志Reply log</strong>结合<strong>模糊快照Fuzzy Snapshot</strong>来对服务器故障进行容错。重放日志在将更新操作体现在内存数据之前先写入外存日志中避免数据丢失；模糊快照在周期性对内存数据做数据快照时，并不对内存数据加锁，而是用深度遍历的方式将内存中的数据结构转入外存快照数据中，这样就存在在做数据快照时内存数据可能发生变化而本次快照数据并未体现这一变化的问题，称之为“模糊”。</p>

<p>因为zk可以保证数据更新操作是幂等的，即只要保证操作执行顺序不变，即使多次执行同一操作对最终结果也没有影响，所以服务器故障恢复时加载进模糊快照并根据重放日志重新执行一遍操作也没有问题。</p>

<hr />

</body>
</html>

