<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>应用场景</title>
	</head>
<body>
<h1>应用场景</h1>

<hr />

<h2>数据发布/订阅</h2>

<p>数据发布/订阅系统，即配置中心。</p>

<p>发布者将数据发布到zk的一个或一系列节点上，供订阅者进行数据订阅，进而达到动态获取数据的目的，实现配置信息的集中式管理和数据的动态更新。</p>

<p>发布/订阅系统一般有两种设计模式：push和pull。</p>

<p>Zk采用push、pull相结合的方式：客户端向服务端注册自己需要关注的节点，一旦该节点的数据发生变更，服务端就会向相应的客户端发送Watcher事件通知，客户端接收到这个消息通知之后，需要主动到服务端获取最新的数据。</p>

<hr />

<h2>命名服务</h2>

<p>命名服务是分布式系统最基本的公共服务之一。在分布式系统中，被命名的实体通常可以是集群中的机器、提供的服务地址或远程对象等。通过使用命名服务，客户端应用能够根据指定名字来获取资源的实体、服务地址和提供者的信息等。</p>

<p>广义上的命名服务的资源定位不是真正意义上的实体资源--在分布式环境中，上层应用仅仅需要一个全局唯一的名字，这时可以使用zk来实现<strong>分布式全局唯一ID的分配机制</strong>。</p>

<p>通过调用zk创建节点的API接口创建一个顺序节点，并在API返回值中获取这个节点的完整名字，利用这个特性就可以借助zk生成全局唯一的ID。</p>

<hr />

<h2>分布式协调/通知</h2>

<p>分布式系统中通常需要一个协调者来控制整个系统的运行流程，例如分布式事务的处理、机器间的互相协调等。引入这样一个协调者，也便于将分布式协调的职责从应用中分离出来，减少耦合性，提高可扩展性。</p>

<p>Zk中特有的Watcher注册与异步通知机制，能够很好的实现分布式系统中不同机器之间的协调与通知，从而实现对数据变更的实时处理。</p>

<p>通常做法是不同客户端对zk上的同一个数据节点进行Watcher注册，监听数据节点的变化（包括数据节点本身及其子节点），如果数据节点发生变化，那么所有订阅的客户端都能够接收到相应的Watcher通知。</p>

<h3>一种通用的分布式系统机器间通信方式</h3>

<h4>心跳检测</h4>

<p>在分布式环境中，不同机器之间需要检测到彼此是否在正常运行，常见心跳检测方法有相互PING，或者在机器之间建立长连接，通过TCP连接固有的心跳检测机制来实现。</p>

<p>Zk实现心跳检测的方式是，基于zk的临时节点特性，可以让不同机器都在zk的一个指定节点下创建临时子节点，不同的机器之间可以根据这个临时节点来判断对应的客户端机器是否存活。</p>

<h4>工作进度汇报</h4>

<p>在一个常见的任务分发系统中，通常任务被分发到不同的机器上执行，需要实时地将自己的任务执行进度汇报给分发系统。</p>

<p>在zk上选择一个节点，每个人物客户端在这个节点下创建临时子节点，来实现两个功能：</p>

<ul>
	<li>通过判断临时节点是否存活来确定任务机器是否存活；</li>
	<li>各个任务机器实时将任务执行进度写到临时节点上去，以便中心系统能够实时获取到任务的执行进度</li>
</ul>

<hr />

<h2>Leader Election</h2>

<p>分布式系统一般采取一主一备或者一主多备，当主控服务器发生故障后，由某台备机接管主控服务器功能成为新的主控机，称为Leader选举。</p>

<p>zk在实现Leader选举时，将临时节点Z设置为Leader专用节点，节点内容存储Leader的地址信息及其他辅助信息。</p>

<p>每个进程（或机器）实现Leader选举过程：进程p读取Z内容并设置观察标识，如果读取操作成功，说明目前已有Leader并可从读取结果中获得Leader相关信息；如果读取失败，说明没有Leader，则进程p试图自己创建该节点（临时节点方式），并将自己的相关信息写入。如果创建并写入成功则p成为Leader，其他非Leader因为设置了观察标识，所以zk会通知所有非Leader说Leader发生了变化，非Leader可以读取Z内容获取最新Leader信息。如果Leader发生故障，创建的临时节点Z失效，其他非Leader节点收到变化通知，按照相同流程继续竞争称为Leader。</p>

<hr />

<h2>集群管理</h2>

<h3>组成员管理（Group Membership）</h3>

<p>组成员管理的任务目标是动态监控一个组内成员的变化情况，比如有成员加入群组或者离开群组。</p>

<p>场景：如果整个系统工作负载太大，可以增加工作服务器来进行负载均衡，而主控服务器需要自动发现新加入的机器；当某个工作服务器发生故障，主控服务器需要尽快发现这一状况。</p>

<p>为了进行组成员管理，可以在zk中指定一个节点代表某个群组，当某个组成员加入群组，在Z节点下创建临时子节点代表组成员，负责组成员管理的监控进程可以调用getChildren来获知群组下所有成员信息，当节点发生变化时获得通知消息。</p>

<h3>任务分配</h3>

<p>对于监控进程来说，创建任务队列管理节点tasks，所有新进入系统的任务都可以在tasks节点下创建子节点，监控进程观察tasks节点的变化。</p>

<p>当有新增任务task-j时zk通知监控进程，监控进程找到新增任务并将其分配给机器i，然后在machines目录下对应的m-i节点创建子节点task-j。</p>

<p>每台工作服务器在machines节点下创建对应子节点，并监听这个子节点的变化，当m-i发现有新增子节点task-j时，读出任务信息并执行；执行完后，将task-j子节点删除，同时删除tasks节点下的task-j子节点。</p>

<hr />

<h2>分布式锁</h2>

<h3>为何需要分布式锁</h3>

<ul>
	<li>效率：避免不同节点重复相同的工作，这些工作会浪费资源</li>
	<li>正确性：避免多个节点机器操作同一条数据</li>
</ul>

<h3>分布式锁的特点</h3>

<ul>
	<li>互斥性：分布式锁要保证不同节点不同线程的互斥</li>
	<li>可重入性：同一个节点上的同一个线程如果获取了锁那么也可以再次获取这个锁</li>
	<li>锁超时：防止死锁</li>
	<li>高效、高可用：加锁和解锁需要高效，同时需要保证高可用防止分布式锁失效，可以增加降级</li>
	<li>支持阻塞和非阻塞</li>
	<li>支持公平锁和非公平锁（可选）：公平锁是指按照请求加锁的顺序获得锁，非公平锁是无序的</li>
</ul>

<h3>算法流程</h3>

<figure><img src="/Users/xerxes/note/zookeeper/src/zk%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png"/></figure>

<p>假设锁空间的根节点为/lock：</p>

<ol>
	<li>客户端连接zk，在/lock下创建<strong>临时</strong>且<strong>有序</strong>子节点，第一个客户端对应的子节点为/lock/lock-0000000000，第二个为/lock/lock-0000000001，以此类推（临时节点能够保证在故障的情况下锁能够被释放）</li>
	<li>客户端获取/lock下的子节点列表，判断自己创建的子节点是否为当前子节点列表中<strong>序号最小</strong>的子节点，如果是则认为获得锁；<s>否则监听/lock的子节点变更消息</s>，<strong> 否则监听刚好在自己之前一位的子节点删除消息</strong> ，获得子节点变更通知后重复这一步直至获得锁（zk提供的API中设置监听器的操作与读操作是原子执行的，在读子节点列表的同时设置监听器，保证不会丢失事件）</li>
	<li>执行业务代码</li>
	<li>完成业务流程，删除对应的子节点释放锁</li>
</ol>

<p>开源项目curator提供了zk分布式锁实现</p>

</body>
</html>

