<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>一致性 &amp; 共识</title>
	</head>
<body>
<h1>一致性 &amp; 共识</h1>

<hr />

<h2>Consensus</h2>

<p>更准确的翻译是<strong>共识，关注的是多个提议者达成共识的过程</strong>。</p>

<p>比如Paxos，Raft 等共识算法，<strong>本质上解决的是如何在分布式系统中保证所有节点对某个结果达成共识</strong>，其中需要考虑节点宕机、网络延迟、网络分区等问题。</p>

<p>由于最终目标是所有节点达成一致，所以根本不存在一致性强弱之分。只有当使用像Paxos 这样的共识算法作为解决副本问题的核心组件时，通常是变种的Paxos 作为核心实现Replication State Machine，才会对外展现出不同的一致性级别。</p>

<p><strong>共识算法通常应用在复制状态机中，比如etcd，zookeeper，用于构建高可用容错系统。在这种应用场景下，Raft、Paxos 共识算法被用来确保各个复制状态机（节点）的日志是一致的</strong>。</p>

<p>类似的，共识算法在区块链中也非常重要，但区块链通常用的是POW（Proof of work）或者POS（Proof of stack），这类共识算法通常用在公网，去中心化的情形下。</p>

<hr />

<h2>Coherence</h2>

<p>Coherence通常出现在Cache Coherence一词中，作为<strong>缓存一致性</strong>被提出。</p>

<p>现代多核CPU Cache都是多层结构，通常每个CPU Core都有一个私有的LB/SB，L1，L2级Cache，多个CPU core共享一个L3级Cache。</p>

<p>当CPU1修改全局变量并写入了L1 Cache中，CPU2想要读取此变量时，就需要Cache Coherence来保证CPU2读取到的是最新变量。<strong>CC的本质是让多组Cache看起来就像一组Cache一样</strong>。</p>

<hr />

<h2>ACID Consistency</h2>

<p>ACID中的一致性指的是数据库的一致性约束，完全与数据库规则有关，包括约束、级联、触发器等。在事务开始之前和事务结束之后，都必须遵守这些不变量，保证数据库的完整性不被破坏。</p>

<p>ACID里的AID都是数据库的特征,也就是依赖数据库的具体实现.而唯独这个C,实际上它依赖于应用层,也就是依赖于开发者.这里的一致性是指系统从一个正确的状态,迁移到另一个正确的状态.什么叫正确的状态呢?就是当前的状态满足预定的约束就叫做正确的状态.而事务具备ACID里C的特性是说通过事务的AID来保证我们的一致性.做个比喻事务就好比一个保镖,我们提到事务就会说ACID,而我们提到保镖会说强壮,保护安全,好功夫,踏实.这里强壮,好功夫和踏实都是保镖自己的特征,而安全是属于你的,而你通过保镖的特征来保护你的安全.但是这里必须注意,我们能够通过AID保证我们的一致性,但事务本身没办法确保.用上面保镖的例子来说,你正常被保护一定是安全的,但是你故意骗保镖离开你身边,然后你自己溜出去玩.同样,如果你在事务里故意写出违反约束的代码,比如银行系统定时每天给自己的账户打入100w,这个事务是没办法的。</p>

<hr />

<h2>CAP Consistency</h2>

<p>一致性（Consistency）在分布式系统中指的是<strong>副本（Replication）问题</strong>中对于同一个数据的多个副本，其对外表现的数据一致性。</p>

<h3>一致性模型分类</h3>

<p>从严格意义上来讲，理想情况下，真正的一致性模型只有一种，即我们常说的<strong>强一致性</strong>。意思是<strong>当对某个数据进行了一个更新操作后，所有后续的观察者都应该感知到这次数值变化并以此为基础进行后续的读/写行为</strong>。</p>

<p>但真实情况下，多数NoSQL系统采用的都是弱一致性模型。这是多机分布情况下追求高可用性和高扩展性必须要做的妥协。因为根据CAP理论可知：在有些情况下，没有系统能够同时满足一致性、可用性和分区容忍性。而对于互联网环境下的分布式计算系统，分区容忍性是一个先天设定的场景，存储系统只能从一致性和可用性中选择一个因素来构建具体系统。</p>

<p>一致性模型包括：强一致性、弱一致性、最终一致性、因果一致性、“读你所写”一致性、会话一致性、单调读一致性以及单调写一致性。</p>

<figure><img src="/Users/xerxes/note/bigDataTec/src/%E4%B8%80%E8%87%B4%E6%80%A7%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg"/></figure>

<p>如图可知，最终一致性是弱一致性的一种特殊情况，而除了强一致性之外，其他模型都属于最终一致性模型的特例或者变体。</p>

<h4>强一致性</h4>

<p>也就是<strong>线性一致性（Linearizability），也称为原子一致性（atomic consistency）</strong>。线性一致性强于顺序一致性，是程序能实现的最高的一致性模型，也是分布式系统用户最期望的一致性。</p>

<p>理想情况下，希望整个分布式系统中的所有事件都有先后顺序，这种顺序就是全序，即整个事件集合中任意两个事件都有先后顺序。但是1. 物理时间很难同步；2. 网络是异步的。因此分布式系统中，想要维持全序是非常困难的。</p>

<p>不同的节点对两个事件谁先发生可能具有不同的看法，并且大部分时候我只需要知道偏序关系，用于确保因果关系。所谓偏序关系是指:</p>

<ol>
	<li>如果a和b是同一个进程中的事件，并且a在b前面发生，那么 a-&gt;b；</li>
	<li>如果a代表了某个进程的消息发送事件，b代表另一进程中针对这同一个消息的接收事件，那么a-&gt;b；</li>
	<li>如果 a-&gt;b且b-&gt;c，那么a-&gt;c (传递性)</li>
</ol>

<p>逻辑时间中的 Lamport Clock和Vector Clock等都可以用于建立偏序关系。</p>

<p><strong>与顺序一致性相比，线性一致性只多了一条约束：如果事件A开始时间晚于事件B结束时间，则在最终事件历史中，要求B在A前</strong>。</p>

<p>不能满足强一致性的情形皆可统称为弱一致性。</p>

<h4>最终一致性</h4>

<p>最终一致性是一种弱一致性。它无法保证某个数据做出更新后，所有后续针对这个数据的操作能够立即看到新数据，而是需要一个时间段，时间段内数据也许是不一致的，在这个时间段之后可以保证这一点，这个时间段称为“不一致窗口”。</p>

<p>在分布式环境下，为了达到高可用性，同一份数据通常被存储到多个机器节点。不同进程可能操作数据的不同备份，当某进程对数据做了更新，需要一定时间来将这个新数据传播到数据的所有其他备份中，而这个时间区间就是不一致窗口。</p>

<h4>因果一致性</h4>

<p>在进程之间有因果依赖关系的情形下，当进程A将数据更新后，会通知进程B数据做出了更新，进程B之后的操作会以新数据作为基础进行读/写。即进程A和进程B保持了数据的因果一致性。而对其他进程来说，还是会在不一致窗口中看到数据的旧值。</p>

<h4>“读你所写”一致性</h4>

<p>因果一致性的特例，在概念上可理解为：进程A更新了一条数据，立即给自己发出一条数据发生变化的通知，所以进程A之后的操作都以新数据作为基础。其他进程不受影响，在不一致窗口内仍旧可能会看到x的旧值。</p>

<h4>会话一致性</h4>

<p>“读你所写”一致性的一种现实版本变体即“会话一致性”。当进程A通过会话与数据库系统连接，在同一个会话内，可以保证其“读你所写”一致性。而在不一致窗口内，如果因为系统故障等原因导致会话结束，那么进程A可能读到旧值。</p>

<h4>单调读一致性</h4>

<p>最终一致性的另一种变体。它保证如果某个进程读取到数据的某个版本，那么系统所有后续的读取操作都不能看到比这个版本老的数据。</p>

<h4>单调写一致性</h4>

<p>另外一种最终一致性的另一种变体。对于某进程来说，单调写一致性可以保证其多次写操作的序列化，如果没有这种保证，对于开发者来说很难进行程序开发。</p>

<h4>顺序一致性 Sequential Consistency</h4>

<p>SC最早用来描述多核CPU的行为，其定义：</p>

<blockquote>
<p>the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.</p>
</blockquote>

<p><strong>如果可以找到一个所有CPU执行指令的排序，该排序中每个CPU要执行指令的顺序得以保持，且实际的CPU执行结果与该指令排序的结果一致，则称该次执行达到了顺序一致性</strong>。</p>

<p>SC保证了两点：</p>

<ul>
	<li>每个线程内部的指令都是按照程序规定的顺序执行的；</li>
	<li>保证上一点的基础上，线程之间是可以交错执行的</li>
</ul>

<h5>多核处理器的顺序一致性</h5>

<p>CPU执行的主要瓶颈在与内存交互，为了让CPU高速执行，CPU内部使用了多级缓存。多级缓存的存在，可能导致CPU内部顺序执行的命令会不满足顺序一致性：</p>

<figure><img src="/Users/xerxes/note/bigDataTec/src/%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8F%8D%E4%BE%8B.jpg"/></figure>

<p>CPU执行命令时会乱序执行，例如在一些情况下CPU会将数据写入的指令提前执行，因为写入内存是很耗时的。同理，编译器在编译代码时也会重排指令的顺序，以提升整体的性能。</p>

<p>现代硬件体系遵循的其实是<strong>sequential consistency for data race free programs</strong>，即如果程序没有数据竞争，则CPU可以保证顺序一致性，如果遇到数据竞争，就需要在程序中使用数据同步的机制（如加锁）。</p>

<h5>ZooKeeper的顺序一致性</h5>

<p>ZooKeeper的一致性保证第一条是：</p>

<blockquote>
<p>Sequential Consistency : Updates from a client will be applied in the order that they were sent.</p>

<p>顺序一致性：客户端发送的更新指令，服务端会按照它们发送的顺序执行。</p>
</blockquote>

</body>
</html>

