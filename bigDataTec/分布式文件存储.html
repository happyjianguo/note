<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>分布式文件存储</title>
	</head>
<body>
<h1>分布式文件存储</h1>

<hr />

<h3>HDFS</h3>

<p>参考HDFS专结</p>

<hr />

<h3>文件存储布局</h3>

<p>底层文件存储布局对于将数据加载入数据仓库的效率、响应用户查询的速度，以及对于底层存储架构磁盘空间利用率的提升都有直接且重要的影响。</p>

<h5>行式存储</h5>

<p>行式存储广泛使用在主流关系型数据库及HDFS文件系统中，每条记录的各个字段连接存储在一起，文件中的各个记录也是连续存储在数据块中。</p>

<p>对于构建大数据分析系统来说，行式存储布局有两个明显缺陷：</p>

<ul>
	<li>其一是对于很多sql查询来说，其所需读取的记录可能只涉及整个记录所有字段中的部分字段。行式存储需要读取整个记录才能读取所需字段</li>
	<li>尽管在存储时可以使用数据压缩模式，但是对于记录的所有字段只能采用统一的压缩算法，这样的压缩模式导致数据压缩率不高，所以磁盘利用率也不高</li>
</ul>

<p>行式存储的优势在于应用需要按行遍历或者查找数据。</p>

<h5>列式存储</h5>

<p>列式存储布局在实际存储数据时，按照列对所有记录进行垂直划分，将同一列的内容连续放在一起。</p>

<p>记录数据的格式有简单和复杂两种。简单的记录数据格式类似于传统数据库的‘记录-字段’这种平面型数据结构，而复杂的记录格式则可能是嵌套的记录结构，比如json格式。</p>

<ol>
	<li>列族方式

		<p>典型的列式存储布局是按照记录的不同列，对数据表进行垂直划分，同一列的所有数据连续存储在一起。</p>

		<ul>
			<li>优点：sql查询只涉及记录的个别列时，只需读取对应的列内容即可；可以针对每列数据的类型采取数据压缩算法</li>
			<li>缺点：当任务需要遍历每条数据处理记录的多个字段时需要从列式数据拼接成原始记录，效率低下</li>
		</ul>

		<p>列族是将记录的列进行分组，将经常一起使用的列分为一组</p></li>
	<li>Dremel的列存储方式

		<p>Dremel是Google开发的对海量数据进行交互式查询与数据分析应用场景的大数据分析系统，其实现了针对复杂嵌套数据的列式存储。数据模型可以定义为：</p>

		$$ t = dom | (A_1 : t[*|?], ..., A_n : t[*|?]) $$
		<p>t可以是原子型或者记录型结构，所谓原子型是指整数型、浮点数型或者字符串型等基础类型；</p>

		<p>每个记录可以由若干字段构成，第i个字段为$A_i$，字段内容可带有描述符*或者？；</p>

		<p>描述符*代表可重复（repeated），即可出现0次或者多次，描述符？代表可选（optional），即可出现0次或者1次，如果没有这两个描述符，则默认语义为必有（required），即必须出现1次。</p>

		<p>为了能够对复杂嵌套数据进行列式存储，还要额外记载两个信息：重复层（repetition level）和定义层（definition level）。</p>

		<p>重复层：某个数据项的全路径所在的重复层级，为了鉴别其具体出现的位置。取值为0时表示该值第一次出现，取值为1时表示与上个数据项相比，该值的第一个层级处于相同层级</p>

		<p>定义层：某个数据项在文档内定义到其全路径的第几层。</p></li>
</ol>

<h5>混合式存储</h5>

<p>将记录表按照行进行分组，若干行分为一组；对于每组内的所有记录，在实际存储时按照列将同一列内容连续存在一起。列式存储的同时保证同一行的记录在同一台机器节点上。</p>

<ol>
	<li>RCFile

		<p>将记录表内的记录按照行划分为行组（Row Group），HDFS每个数据块可以包含多个行组数据。每个行组存储3类信息：Sync是行组同步标识，识别是否是数据块中一个新的行组开始；元数据记录了这个行组包含多少记录；然后是实际数据，在数据块中按照列式存储。</p>

		<figure><img src="/Users/xerxes/note/bigDataTec/src/RCFile%E6%B7%B7%E5%90%88%E5%BC%8F%E5%AD%98%E5%82%A8.jpg"/></figure></li>
	<li>ORCFile

		<p>orc包含若干数据行组，每个数据行组被称为数据带（stripe），文件尾（file footer）记录文件中所有数据带的元信息（包括有多少个数据带，每个数据带包含的记录数及每列采用何种数据压缩算法等）。</p>

		<p>每个数据带由3类信息构成：行数据区（Row Data）按列存储该行组记录的实际数据；数据带尾（Stripe Footer）记录压缩数据流的位置信息；索引数据（Index Data）记录该行组所有记录中每一列的最大值和最小值和行组内部分记录的每一列字段在行数据区的位置信息。</p>

		<figure><img src="/Users/xerxes/note/bigDataTec/src/ORCFile%E5%AD%98%E5%82%A8.jpg"/></figure></li>
	<li>Parquet

		<p><strong>特点</strong>：</p>

		<ul>
			<li>列裁剪：只读取需要的列，高效列扫描，减少IO</li>
			<li>谓词下推：过滤掉不符合条件的数据，减少IO</li>
			<li>高效压缩与编码：同一列数据类型相同，使用更合适的压缩与编码算法，降低磁盘存储空间</li>
		</ul>

		<p><strong>数据模型</strong>：</p>

		<p>Parquet是一种支持嵌套的数据模型，schema就是一个嵌套的message。每个schema的字段有三种属性：repetition、type、name。repetition有三种：required（出现一次），repeated（0次或多次），optional（0次或1次）。每个字段的数据类型有两种：group（复杂类型）和primitive（基本类型）。</p>

		<p><strong>文件格式</strong>：</p>

		<figure><img src="/Users/xerxes/note/bigDataTec/src/Parquet%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.jpeg"/></figure>

		<ul>
			<li>文件（File）：由header、行组和footer组成。header包含一个4个字节的数字PAR1用来识别整个Parquet文件格式；footer包含所有metadata（Parquet文件有三种类型的元数据：file metadata、column chunk metadata、page header metadata）和统计信息；</li>
			<li>行组（Row Group）：数据在水平方向上按行拆分为多个单元，即行组。每个行组包含一定的行数，Parquet读写的时候会将整个行组缓存在内存中</li>
			<li>列块（Column Chunk）：一个行组中的每一列保存在一个列数据块，包括这一列的repetion level、defintion level和values。行组中所有列连续存储在行组文件中</li>
			<li>数据页（Data Page）：每一个列数据块划分为多个数据页，一个页是最小的编码单位</li>
		</ul></li>
</ol>

<hr />

<h3>Google文件系统（GFS）</h3>

<p>GFS是Google为了能够存储以百亿计的海量网页信息而专门开发的文件系统。</p>

<p>在Google的整个大数据存储与处理技术框架中，GFS是其他相关技术的基石，因为GFS提供了海量非结构化信息的存储平台，并提供了数据的冗余备份、成千台服务器的自动负载均衡以及失效服务器检测等各种完备的分布式存储功能。只有在GFS提供的基础功能至上，才能开发更加符合应用需求的存储系统和计算框架。</p>

<h5>GFS设计原则</h5>

<ul>
	<li>GFS采用大量商业PC来构建存储集群，经常发生机器死机或者硬盘故障，因此，数据冗余备份、自动检测机器是否还在有效提供服务、故障机器的自动恢复等都在GFS的设计目标里。</li>
	<li>GFS文件系统所存储的文件绝大多数都是大文件，所以系统的设计应该针对这种大文件的读/写操作做出优化。</li>
	<li>系统中存在大量的“追加写”操作，即将新增内容追加到已有的文件的末尾，已经写入的内容一般不做更改，很少有文件的“随机写”行为，即将数据写入指定已有文件中间某个位置。</li>
	<li>对于数据读取操作来说，绝大多数读文件操作都是“顺序读”，少量操作是“随机读”，即按照数据在文件的顺序，一次顺序读入较大量的数据，而不是不断地定位到文件指定的位置，读取少量数据。</li>
</ul>

<h5>GFS整体架构</h5>

<p>GFS文件系统主要由3个组成部分构成：唯一的“主控服务器（Master）”、众多的“Chunk服务器”和“GFS客户端”。</p>

<p>主控服务器主要做管理工作，Chunk服务器负责实际的数据存储并响应GFS客户端的读/写请求。尽管GFS由上千台服务器构成，但是在开发者眼中，GFS类似于本地的统一文件系统，分布式存储系统的细节对开发者来说是不可见的。</p>

<hr />

<h3>纠删码</h3>

<p>通过纠删码算法将原始的数据进行编码得到冗余，并将数据和冗余一并存储，以达到容错的目的。与数据副本相比冗余度更低，磁盘利用率更高。</p>

<p>基本思想：将n块原始数据元素通过一定的计算，得到m块冗余元素（校验块）。对于这n+m块元素，当其中任意m块元素出错，均可以通过对应的重构算法恢复原来的n块数据。磁盘利用率n/(n+m)。</p>

<h5>Reed-Solomon(RS)码</h5>

<p>Reed-Solomon（RS）码是存储系统较为常用的一种纠删码，它有两个参数n和m，记为RS(n,m)。n代表原始数据块个数。m代表校验块个数。</p>

<p><strong>原理</strong>：</p>

<p>以n=5，m=3为例。即5个原始数据块，乘上一个(n+m)*n的矩阵，然后得出一个(n+m)*1的矩阵。根据矩阵特点可以得知结果矩阵中前面5个值与原来的5个数据块的值相等，而最后3个则是计算出来的校验块。</p>

<figure><img src="/Users/xerxes/note/bigDataTec/src/rs_%E7%BC%96%E7%A0%81%E8%BF%87%E7%A8%8B.jpg"/></figure>

<p>假设丢失了m块（可能包含原始数据块或者校验块），就要通过解码过程来恢复原始数据块。</p>

<ol>
	<li>从编码矩阵中删去丢失数据块和丢失编码块对应行。 将删掉m个块的(n+m)*1个矩阵变形为n*1矩阵，同时B矩阵也需要删掉对应的m个行得出一个B&#39;的变形矩阵，这个B&#39;就是n*n矩阵。如下：假设D1、D4、C2丢失，我们得到如下B’矩阵及等式。

		<figure><img src="/Users/xerxes/note/bigDataTec/src/rs_%E8%A7%A3%E7%A0%81%E7%AC%AC%E4%B8%80%E6%AD%A5.jpg"/></figure></li>
	<li>求B’的逆矩阵，等式两边分别乘上B’的逆矩阵

		<figure><img src="/Users/xerxes/note/bigDataTec/src/rs_%E8%A7%A3%E7%A0%81%E7%AC%AC%E4%BA%8C%E6%AD%A5.jpg"/></figure></li>
	<li>即可得到原始矩阵D：

		<figure><img src="/Users/xerxes/note/bigDataTec/src/rs_%E8%A7%A3%E7%A0%81%E7%AC%AC%E4%B8%89%E6%AD%A5.jpg"/></figure></li>
</ol>

<p><strong>RS的特点</strong>：</p>

<ul>
	<li>低冗余度，高磁盘利用率。</li>
	<li>数据恢复代价高。 丢失数据块或者编码块时， RS需要读取n个数据块和校验块才能恢复数据， 数据恢复效率也在一定程度上制约了RS的可靠性。</li>
	<li>数据更新代价高。 数据更新相当于重新编码， 代价很高， 因此常常针对只读数据，或者冷数据。</li>
</ul>

<p>工程实践中，一般对于热数据还是会使用多副本策略来冗余，冷数据使用纠删码。</p>

</body>
</html>

