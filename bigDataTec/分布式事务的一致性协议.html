<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>分布式事务的一致性协议</title>
	</head>
<body>
<h1>分布式事务的一致性协议</h1>

<hr />

<h2>Paxos协议</h2>

<h3>副本状态机副本（Replicated State Machines）</h3>

<p>在分布式环境下，一致性协议的应用场景一般会采用副本状态机来表达，这是对各种不同应用场景的一种抽象化表述。</p>

<figure><img src="/Users/xerxes/note/bigDataTec/src/%E5%89%AF%E6%9C%AC%E7%8A%B6%E6%80%81%E6%9C%BA.jpg"/></figure>

<p>集群中多台服务器各自保存一份Log副本及内部状态机，Log内顺序记载客户端发来的操作指令，服务器依次执行Log内的指令并将其体现到内部状态机上，如果保证每台机器内的Log副本内容完全一致，那么对应的状态机也可以保证整体状态一致。一致性协议的作用就是保证各个Log副本数据的一致性，即图中一致性模块起的作用。</p>

<p>某台服务器在接收到客户端的操作指令后，将其追加到自身的Log尾部，然后和其他服务器的一致性模块进行通信，保证其他服务器（即使有服务器发生故障）的Log最终能够以同样的顺序保存同样的操作指令，当操作指令能够正确复制，那么每台服务器按照Log内记录顺序执行操作指令，最终所有服务器的内部状态保持一致，服务器将执行操作命令后的状态结果返回客户端作为操作结果。通过这种方式使得整个集群对于外部客户端看起来就像单机一样。</p>

<p>实际实现副本状态机中的一致性协议时，往往追求几个特性：</p>

<ul>
	<li>安全性：即非拜占庭模式下，状态机从不返回错误的结果，多个提议中只会有一个被选中</li>
	<li>可用性：只要大多数服务器正常，整个服务就保持可用</li>
	<li>一般情况下，大多数状态机维护Log一致即可快速通知客户端操作成功，这样避免了少数最慢的状态机拖慢整个请求响应速度</li>
</ul>

<h3>Paxos基本概念</h3>

<p><strong>Paxos又可以细分为两种</strong>：</p>

<ul>
	<li>单Paxos（Single-Decree Paxos）

		<p>副本状态机中各个服务器针对Log中固定某个位置的操作命令通过协议达成一致，因为可能某一时刻不同服务器的Log中相同位置的操作命令不一样，通过执行协议后使得各个服务器对应某个固定位置的操作命令达成一致</p></li>
	<li>多Paxos（Multi-Paxos）

		<p>指这些服务器对应的Log内容中多个位置的操作命令序列通过协议保持一致。多Paxos往往是同时运行的多个单Paxos协议共同执行的结果。</p></li>
</ul>

<p><strong>并行进程（对应副本状态机上每台服务器的一致性模块）分为三种角色</strong>：</p>

<ul>
	<li>倡议者（Proposer）：倡议者可以提出提议以供投票表决</li>
	<li>接受者（Acceptor）：接受者可以对提议者提出的提议进行投票表决，从众多提议中选出唯一确定的一个</li>
	<li>学习者（Learner）：学习者无倡议投票权，但是可以从接受者那里获知是哪个提议最终被选中</li>
</ul>

<p><strong>异步通信环境下的非拜占庭模型（Non-Byzantine Model）</strong>：</p>

<ul>
	<li>并发进程的行为可以以任意速度执行，允许运行失败，在失败后也许会重启并再次运行</li>
	<li>并发进程之间通过异步方式发送信息通信，通信时间可以任意长，信息可能会在传输过程中丢失，也允许重复发送相同的消息，多重信息的顺序可以任意。但是有一点：信息不允许被篡改（真实分布式计算环境下可以通过内容完整性检测来解决）</li>
</ul>

<p>Paxos协议以及很多一致性协议都是基于非拜占庭模型的，即在非拜占庭条件下Paxos协议可以就不同提议达成一致，而在拜占庭模型下情况会更加复杂</p>

<h3>Paxos一致性协议</h3>

<p>Paxos的目的是在非拜占庭条件下，当多个并行进程提出不同的操作指令时，如何能够达成一致。Paxos协议可以描述为两阶段过程：</p>

<ul>
	<li>阶段一

		<p>1.1【倡议者视角】倡议者选择倡议编号n，然后向大多数（超过半数以上）接受者发送Prepare请求，请求中附带倡议编号n</p>

		<p>1.2【接受者视角】对于某个接受者来说，如果接收到带有倡议编号n的Prepare请求，则做判断：若倡议编号n比此接受者之前响应过的任何其他Prepare请求附带的倡议编号都大，那么此接受者会给倡议者响应，并承诺不会响应之后接收到的其他任何倡议编号小于n的请求；如果接受者曾经响应过2.2阶段的Accept请求，则将所有响应的Accept请求中的倡议编号最高的倡议内容发送给倡议者，倡议内容包括两项信息：Accept请求中的倡议编号以及倡议值。若倡议编号n不比此接受者之前响应过的任何其他Prepare请求附带的倡议编号都大，那么此接受者不会给倡议者响应</p></li>
	<li>阶段二

		<p>2.1【倡议者视角】如果倡议者接收到大多数接受者关于带有倡议编号n的Prepare请求的响应，那么倡议者向这些接受者发送Accept请求，Accept请求附带两个信息：倡议编号n以及倡议值v。倡议值v的选择方式如下：如果在1.2阶段接受者返回了自己曾经接受的具有最高倡议编号Accept请求倡议内容，则从这些倡议内容里面选择倡议编号最高的并将其倡议值作为倡议值v；如果1.2阶段没有接收到任何接受者的Accept请求倡议内容，则可以任意复制给倡议值v。</p>

		<p>2.2【接受者视角】如果接受者接收到了任意倡议编号为n的Accept请求，则接受者接收此请求，除非在此期间接受者响应过具有比n更高编号的Prepare请求。</p>

		<p>通过这两个阶段即可选出唯一的倡议值。对于学习者来说，其需要从接受者那里获知选出的倡议值。方法是：</p></li>
	<li>每当接受者执行完步骤2.2，即接收某个Accept请求后，由其通知所有学习者其接收的倡议。但是这样会导致大量通信因为任意一个接受者都会通知任意一个学习者</li>
	<li>替代策略：从众多学习者选择一个作为代表，由其从接受者那里获知最终被选出的倡议，然后由其通知其他学习者，但是如果这个学习者代表出现故障，则其他学习者无法获知倡议值</li>
	<li>折中方法：选出若干学习者代表，由这些代表从接受者那里获知最终倡议值，然后通知其他学习者</li>
</ul>

<p>通过以上流程，如果有多个并发进程提出各自的倡议值，Paxos可以保证从中选出且只选出一个唯一确定的倡议值，以来来达到副本状态机保持状态一致的目标。</p>

<hr />

<h2>两阶段提交协议（Two-Phrase Commit，2PC）</h2>

<p>常见的解决分布式事务问题的方式，可以保证在分布式事务中，<strong>要么所有参与进程都提交事务，要么都取消事务</strong>，即实现ACID中的A的常用手段。</p>

<p>在数据一致性环境下，其代表的含义是：要么所有备份数据同时更改某个数值，要么都不改，以此来达到数据的强一致性。</p>

<p>在实际应用中使用两阶段提交协议来作为数据一致性比较少见，更多的是作为<strong>实现数据更新原子性手段</strong>出现。</p>

<p>在两阶段提交的语境下，存在两类不同实体：唯一的协调者（Coordinator）和众多的参与者（Participants）。协调者起到分布式事务的特殊的管理协调作用。</p>

<p>顾名思义两阶段提交将提交过程划分为连续的两个阶段：表决阶段（Voting）和提交阶段（Commit）。</p>

<figure><img src="/Users/xerxes/note/bigDataTec/src/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.jpg"/></figure>

<ul>
	<li>阶段一：投票阶段

		<ol>
			<li>事务询问：协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应；</li>
			<li>执行事务：各参与者节点执行事务操作，并将undo和redo信息记入事务日志中；</li>
			<li>各参与者向协调者反馈事务询问的请求：如果参与者成功执行了事务操作，那么就反馈给协调者yes响应，表示事务可以执行；如果参与者没有成功执行事务，就反馈给协调者no响应，表示事务不可以执行</li>
		</ol></li>
	<li>阶段二：执行事务提交

		<ul>
			<li>如果协调者从所有参与者获得的反馈都是yes，那么就执行事务提交

				<ol>
					<li>发送提交请求：协调者向所有参与者节点发送commit请求；</li>
					<li>事务提交：参与者收到commit请求，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源；</li>
					<li>反馈事务提交结果：参与者在完成事务提交之后，向协调者发送Ack消息；</li>
					<li>完成事务：协调者接收到所有参与者反馈的Ack消息后，完成事务</li>
				</ol></li>
			<li>如果任意一个参与者向协调者反馈了no响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，则中断事务

				<ol>
					<li>发送回滚请求：协调者向所有参与者节点发出Rollback请求；</li>
					<li>事务回滚：参与者接收到Rollback请求后，会利用其在阶段一中提交的undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源；</li>
					<li>反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送Ack消息；</li>
					<li>中断事务：协调者接收到所有参与者反馈的Ack消息后，完成事务中断</li>
				</ol></li>
		</ul></li>
</ul>

<h3>2PC缺点</h3>

<h4>同步阻塞</h4>

<p>2PC协议最明显也是最大的一个问题就是同步阻塞，极大地限制了分布式系统的性能。</p>

<figure><img src="/Users/xerxes/note/bigDataTec/src/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.jpg"/></figure>

<p>从两者的有限状态机可以看出，在所有可能状态中，存在3个阻塞状态：协调者的WAIT状态、参与者的INIT状态和READY状态，因为这3个状态需要等待对方的反馈信息。如果一个协议包含阻塞态，则明显是一个很脆弱的系统，因为很可能因为有进程陷入崩溃而导致处于阻塞态的对象进入长时间的等待，系统无法继续向后运行。因此引入两种手段：</p>

<ul>
	<li>超时判断机制：解决协调者WAIT状态和参与者INIT状态的长时间阻塞情形</li>
	<li>参与者互询机制：解决大部分情形下参与者READY状态的长时间阻塞可能</li>
</ul>

<h4>单点问题</h4>

<p>2PC协议整个过程中，协调者起到重要作用。一旦协调者出现问题，整个流程都会有问题。更为严重的是如果协调者在阶段二出现问题，其他参与者将会一直处于锁定事务资源的状态，无法继续完成事务操作。</p>

<h4>数据不一致</h4>

<p>在2PC协议第二阶段，如果协调者向所有参与者发送commit请求的时候发生了网络分区，导致只有一部分参与者收到了commit请求，提交了事务，其他没有收到commit请求的参与者无法提交事务，整个分布式系统就会出现数据不一致的情况。</p>

<h4>过于保守</h4>

<p>如果协调者指示参与者进行事务提交询问的过程中，参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的话，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务。</p>

<p>2PC协议没有设计较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败。</p>

<hr />

<h2>三阶段提交协议（Three-Phrase Commit，3PC）</h2>

<h3>协议说明</h3>

<p>3PC是2PC的改进版，其将2PC协议的“提交事务请求”阶段一分为二，形成了由can commit、pre commit和do commit三个阶段组成的事务处理协议。</p>

<figure><img src="/Users/xerxes/note/bigDataTec/src/3PC%E5%8D%8F%E8%AE%AE.jpg"/></figure>

<ul>
	<li>阶段一：can commit

		<ol>
			<li>事务询问：协调者向所有的参与者发送一个包含事务内容的can commit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应；</li>
			<li>各参与者向协调者反馈事务询问的响应：参与者接收到协调者的can commit请求后，正常情况下如果其自身认为可以顺利执行事务，就反馈yes响应，进入预备状态，否则反馈no响应</li>
		</ol></li>
	<li>阶段二：pre commit

		<ul>
			<li>如果协调者从所有参与者获取的反馈都是yes响应，则执行事务预提交

				<ol>
					<li>发送预提交请求：协调者向所有参与者节点发送pre commit请求，并进入prepared阶段；</li>
					<li>事务预提交：参与者接收到pre commit请求后，执行事务操作，并将undo和redo信息记录到事务日志中；</li>
					<li>各参与者向协调者反馈事务执行的响应：如果参与者成功执行了事务操作，那么就会反馈给协调者Ack响应，同时等待最终指令：commit/abort</li>
				</ol></li>
			<li>如果任意参与者向协调者反馈了no响应或者等待超时，则中断事务

				<ol>
					<li>发送中断请求：协调者向所有参与者发送abort请求</li>
					<li>中断事务：无论是受到来自协调者的abort请求还是等待超时，参与者都会中断事务</li>
				</ol></li>
		</ul></li>
	<li>阶段三：do commit

		<ul>
			<li>如果协调者接收到所有参与者的Ack响应

				<ol>
					<li>发送提交请求：协调者从“预提交”状态转换到“提交”状态，并向所有的参与者发送do commit请求；</li>
					<li>事务提交：参与者接收到do commit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的资源；</li>
					<li>反馈事务提交结果：参与者完成事务提交之后，向协调者发送Ack消息；</li>
					<li>完成事务：协调者接收到所有参与者反馈的Ack消息，完成事务</li>
				</ol></li>
			<li>如果任意参与者向协调者反馈no响应或者等待超时，则中断事务

				<ol>
					<li>发送中断请求：协调者向所有参与者节点发送abort请求；</li>
					<li>事务回滚：参与者接收到abort请求，利用阶段二记录的undo信息来执行事务回滚操作，完成后释放整个事务执行期间占用的资源；</li>
					<li>反馈事务回滚结果：参与者完成事务回滚之后，向协调者发送Ack消息；</li>
					<li>中断事务：协调者接收到所有参与者反馈的Ack消息后，中断事务</li>
				</ol></li>
		</ul></li>
</ul>

<hr />

<h2>最终一致性</h2>

<figure><img src="/Users/xerxes/note/bigDataTec/src/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE.jpg"/></figure>

<p>整个流程保证：</p>

<ul>
	<li>业务主动方本地事务提交失败，业务被动方不会收到消息的投递</li>
	<li>只要业务主动方本地事务执行成功，那么消息服务一定会投递给下游的业务被动方，并最终保证业务被动方一定能成功消费该消息</li>
</ul>

</body>
</html>

