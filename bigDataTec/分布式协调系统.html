<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>分布式协调系统</title>
	</head>
<body>
<h1>分布式协调系统</h1>

<p>大规模分布式系统需要解决各种类型的协调需求。</p>

<ul>
	<li>当主控服务器发生故障时，为了使系统不至瘫痪，需要从备份机中选出新的主控服务器</li>
	<li>当分布式系统负载过高，可以动态加入新机器通过水平扩展来进行负载均衡，分布式系统需要自动探测到有一台新机器加入并自动向其分配任务</li>
	<li>分布式环境下实现锁服务</li>
	<li>在多个进程或者机器之间实现任务同步，比如所有进程同时在某个时间点开始或者结束</li>
	<li>判断集群中某台机器是否依然存活</li>
	<li>快速构建生产者-消费者消息队列</li>
</ul>

<hr />

<h3>Chubby锁服务</h3>

<blockquote>
<p>Chubby是Google针对分布式系统协调管理的粗粒度锁服务。这种锁服务的主要功能是让众多客户端程序进行相互之间的同步，并对系统环境或者资源达成一致认知。通过对数据加锁的方式来实现各种分布式环境下的资源协调问题。</p>
</blockquote>

<p>Chubby的锁服务通过多个服务器竞争某个数据的锁，竞争成功的服务器持有锁并成为leader，同时可以将其相应信息写入数据使其对其他竞争者可见。</p>

<p>粗粒度指的是锁的持有时间比较长。这样对锁服务器请求的负载较低，可以支持更高的并发。</p>

<p>Chubby的设计哲学是强调协调系统的可靠性与高可用性及语义易于理解，而不追求处理读/写请求的高吞吐量及在协调系统内存储大量数据。</p>

<p>Chubby的理论基础是Paxos一致性协议，Paxos是在完全分布环境下，不同客户端能够通过交互通信并投票，对于某个决定达成一致的算法。</p>

<p>Paxos是完全分布的，没有中心管理节点，需要通过多轮通信和投票来达成最终一致，所以效率低下。Chubby出于系统效率考虑，增加了一些中心管理策略，在达到同一目标的情况下完善了系统效率。</p>

<h5>系统架构</h5>

<p>Chubby服务由客户端链接的库程序和多个Chubby单元构成。</p>

<p>一般一个数据中心部署一套Chubby单元，每个Chubby单元通常包含5台服务器，通过Paxos协议选举的方式推举其中一台作为主控服务器，所有读/写操作都由主控服务器完成，其他4台作为备份服务器，在内存中维护和主控服务器完全一致的树形结构（里面的内容即为加锁对象或者数据存储对象）。</p>

<h5>数据模型</h5>

<p>Chubby类似于文件系统的目录和文件管理系统，并在此基础上提供针对目录和文件的锁服务。Chubby的文件主要存储一些管理信息或者基础数据。</p>

<p>Chubby在树形目录结构中提供了很多管理功能，如针对某个目录或者文件的加锁服务，针对目录或者文件的访问权限控制，文件内容存取以及时间通知机制。通过这种结构可以有效实现分布式系统中的同步协同和资源管理功能。</p>

<h5>会话与KeepAlive机制</h5>

<p>这里的会话指客户端和主控服务器之间建立的联系通道，会话的维持由周期性进行握手的KeepAlive机制保证。</p>

<p>客户端项主控服务器发出KeepAlive消息（一个RPC调用），服务器在接收到KeepAlive消息后阻塞这个RPC调用，直到客户端原先的租约接近到期为止；此时服务器解除RPC阻塞，KeepAlive调用返回，同时服务器通知客户端拥有一个新的租约；客户端在接收到返回信息后立即再次向服务器发出KeepAlive消息，如此循环往复，形成可靠的KeepAlive消息，客户端不断拥有新租约来延续两者之间会话。</p>

<h5>客户端缓存</h5>

<p>为了减少客户端和服务器之间的通信量，Chubby允许客户端在本地缓存部分服务器数据，由Chubby来保证缓存数据和服务器端数据完全一致。</p>

</body>
</html>

