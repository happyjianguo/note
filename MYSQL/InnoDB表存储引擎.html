<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>InnoDB 表存储引擎</title>
	</head>
<body>
<h1>InnoDB 表存储引擎</h1>

<hr />

<h3>基础特性</h3>

<ol>
	<li>InnoDB的数据存储在<em>表空间</em>中，由一系列的数据文件组成。</li>
	<li>InnoDB使用<em>MVCC</em>来支持高并发，并且实现了四个标准的隔离级别，其默认隔离级别为可重复读。并且通过<em>间隙锁</em>（next-key locking）来防止幻读。</li>
	<li>InnoDB表是基于<em>聚簇索引</em>建立的。每张表的存储都是按主键的顺序进行存放。如果没有显式的在表定义时指定主键，InnoDB会找一列能够唯一标识的列当主键，如果没有就为每一行生成一个6字节的ROWID来做主键。聚簇索引对主键查询有很高的性能。但是非主键索引必须包含主键列。</li>
	<li>InnoDB在内部做了许多优化，包括从磁盘读取数据时采用可预测性预读。</li>
	<li>InnoDB做为事务型引擎，通过一些机制和工具达到真正的热备份。</li>
</ol>

<hr />

<h3>InnoDB体系架构</h3>

<p>InnoDB有多个内存块，可以认为这些内存块组成了一个大的内存池，负责如下工作：</p>

<ol>
	<li>维护所有进程／线程需要访问的多个内部数据结构</li>
	<li>缓存磁盘上的数据，方便快速地读取，同时在对磁盘文件的数据修改之前在这里缓存</li>
	<li>重做日志（redo log）缓冲</li>
</ol>

<figure><img src="/Users/xerxes/note/MYSQL/src/InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.jpg"/></figure>

<h5>后台线程</h5>

<p>后台线程的主要作用是负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据。此外将已修改的数据文件刷新到磁盘文件，同时保证数据库发生异常的情况下InnoDB能恢复到正常运行状态。</p>

<p>InnoDB存储引擎是多线程的模型，因此其后台有多个不同的后台线程，负责处理不同的任务。</p>

<ol>
	<li>Master Thread

		<p>核心后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据一致性。</p></li>
	<li>IO Thread

		<p>在InnoDB中大量使用了AIO（Async IO）来处理IO请求。IO Thread的工作主要负责这些IO请求的回调处理。</p></li>
	<li>Purge Thread

		<p>事务被提交之后，其使用的undolog可能不再需要，因此需要PurgeThread来回收已经使用并分配的undo页。</p></li>
	<li>Page Cleaner Thread

		<p>在InnoDB1.2.x中引入，作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。目的是为了减轻原Master Thread的工作及对于用户查询线程的阻塞，提高InnoDB的性能。</p></li>
</ol>

<h5>内存</h5>

<ol>
	<li>缓冲池

		<p>InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。在数据库系统中，由于CPU速度与磁盘速度之间的鸿沟，通常使用缓冲池（一块内存区域）技术来提高数据库的整体性能。</p>

		<ul>
			<li>读取页的操作，首先将从磁盘读到的页存放在缓冲池中（将页‘FIX’在缓冲池）。下一次再读相同的页时，首先判断该页是否在缓冲池中，如果在—&gt;直接读，不在—&gt;读磁盘。</li>
			<li>修改操作，首先修改缓冲池中的页，然后再以一定的频率刷新到磁盘上。页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过CheckPoint的机制刷新回磁盘。</li>
		</ul>

		<figure><img src="/Users/xerxes/note/MYSQL/src/InnoDB%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1.jpg"/></figure>

		<p>如上图所示，缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等。</p></li>
	<li>LRU List、Free List和Flush List

		<p>通常来说，数据库中的缓冲池是通过<em>LRU（Latest Recent Used）</em>算法来进行管理的。最频繁使用的页在LRU列表的前端，最少使用的页在末端。当缓冲池中不能存放新读取到的页时，首先释放LRU列表末端的页。</p>

		<p>InnoDB中，缓冲池中页的大小默认16KB，使用改进的LRU算法对缓冲池进行管理。在LRU列表中加入了midpoint位置，新读取到的页，虽然是最新访问的页，但并不是直接放入到LRU列表的前端，而是放入到LRU列表的midpoint位置。这个算法称为<em>midpoint insertion strategy</em>。默认配置下，这个位置在LRU的5/8处。</p>

		<p>如果将读取的页放入到LRU列表首部，那么某些sql操作可能会使缓冲池中的页被刷新出。常见的这类操作为索引或数据的扫描操作，这类操作需要访问表中的许多页，这些页通常来说尽在这次查询中需要，因此可能将热点数据页从LRU列表中移除。为解决此问题，InnoDB引入了另外一个参数<code>innodb_old_blocks_time</code>，用于表示读取到mid位置后需要等待多久才会被加入到LRU列表的热端。</p></li>
	<li>重做日志缓冲

		<p>InnoDB的内存区除了有缓冲池外，还有重做日志缓冲。InnoDB首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件。</p></li>
	<li>额外的内存池

		<p>在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。</p></li>
</ol>

<h5>CheckPoint技术</h5>

<p>缓冲池的设计目的是为了协调CPU速度与磁盘速度的鸿沟。因此页的操作首先都是在缓冲池中完成。如果一条DML语句，如update或delete改变了页中的记录，那么此时页是脏的，即缓冲池中的页的版本要比磁盘的新，数据库需要讲新版本的页从缓冲池刷新到磁盘。</p>

<p><em>当前事务数据库系统普遍采用Write Ahead Log策略，即当事务提交时，先写重做日志，再修改页。</em></p>

<p>CheckPoint主要为解决以下问题：</p>

<ol>
	<li>缩短数据库的恢复时间</li>
	<li>缓冲池不够用时，将脏页刷新到磁盘</li>
	<li>重做日志不可用时，刷新脏页</li>
</ol>

<p>当数据库发生宕机时，数据库不需要重做所有日志，因为CheckPoint之前的页都已经刷新到磁盘了，所以只需要对CheckPoint之后的重做日志进行恢复。</p>

<h5>Master Thread 工作方式</h5>

<ol>
	<li>InnoDB 1.0.x 版本之前

		<p>Master Thread 具有最高的线程优先级别。内部由多个循环组成：主循环、后台循环、刷新循环、暂停循环。Master Thread根据数据库的运行状态在循环中进行切换。</p>

		<p><em>主循环</em>分为两部分：每秒操作和每10秒操作。每秒操作包括：</p>

		<ul>
			<li>日志缓冲刷新到磁盘，即使事务还没提交</li>
			<li>合并插入缓冲</li>
			<li>至多刷新100个InnoDB的缓冲池中的脏页到磁盘</li>
			<li>如果当前没有用户活动，则切换到后台循环</li>
		</ul>

		<p>每10秒操作包括：</p>

		<ul>
			<li>刷新100个脏页到磁盘</li>
			<li>合并至多5个插入缓冲</li>
			<li>将日志缓冲刷新到磁盘</li>
			<li>删除无用的undo页</li>
			<li>刷新100个或者10个脏页到磁盘</li>
		</ul>

		<p>当前没有用户活动或者数据库关闭，就会切换到<em>后台循环</em>，执行：</p>

		<ul>
			<li>删除无用的undo页</li>
			<li>合并20个插入缓冲</li>
			<li>跳回到主循环</li>
			<li>不断刷新100个页直到符合条件</li>
		</ul></li>
	<li>InnoDB 1.2.x 版本之前</li>
	<li>InnoDB 1.2.x 版本</li>
</ol>

<h5>InnoDB 关键特性</h5>

<ol>
	<li>插入缓冲

		<p>对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，如果在则插入，如果不在，先放到<em>插入缓冲</em>中，然后再以一定频率进行<em>插入缓冲</em>和辅助索引页子节点的merge操作。</p></li>
	<li>两次写

		<p>当发生部分写失效，先通过页的副本还原该页，再进行重做。</p></li>
	<li>自适应哈希索引

		<p>InnoDB 会监控对表上个索引页的查询，如果观察到建立哈希索引可以带来速度提升，则建立哈希索引。</p></li>
	<li>异步IO</li>
	<li>刷新邻接页

		<p>当刷新一个脏页时，InnoDB 会检测该页所在区的所有页，如果是脏页，则一并刷新。</p></li>
</ol>

</body>
</html>

