<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>并发与多线程</title>
	</head>
<body>
<h1>并发与多线程</h1>

<p>并发是指在某个时间段内，多任务交替处理的能力。并行是指同时处理多任务的能力。</p>

<p>线程是CPU 调度和分派的基本单位，为了更充分地利用CPU 资源，一般都会使用多线程进行处理。</p>

<p>线程可以拥有自己的操作栈、程序计数器、局部变量表等资源，它与同一进程内的其他线程共享该进程的所有资源。</p>

<hr />

<h2>线程安全</h2>

<h3>线程状态</h3>

<p>线程在生命周期内存在多种状态。如下图所示：</p>

<figure><img src="/Users/xerxes/note/java/src/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.png"/></figure>

<h4>NEW</h4>

<p>新建状态，是线程被创建且未启动的状态。</p>

<p>创建线程的方式有三种：</p>

<ul>
	<li>继承Thread 类：这种方式往往不符合里氏代换原则；</li>
	<li>实现Runnable 接口：推荐使用，使变成更加灵活，对外暴露细节比较少；</li>
	<li>实现Callable 接口：可以通过接口的<code>call()</code>方法获得返回值，前两种方式都不能；<code>call()</code>可以抛出异常</li>
</ul>

<h4>RUNNABLE</h4>

<p>就绪状态，是调用<code>start()</code>之后运行之前的状态。</p>

<p>线程的<code>start()</code>不能被多次调用，否则会抛出IllegalStateException 异常。</p>

<h4>RUNNING</h4>

<p>运行状态，是<code>run()</code>正在执行时线程的状态。</p>

<p>线程可能会由于某些因素退出RUNNING，如时间、异常、锁、调度等。</p>

<h4>BLOCKED</h4>

<p>阻塞状态，进入此状态有以下几种情况：</p>

<ul>
	<li>同步阻塞：锁被其他线程占用；</li>
	<li>主动阻塞：调用Thread 的某些方法，主动让出CPU 执行权，如<code>sleep()</code>、<code>join()</code>等；</li>
	<li>等待阻塞：执行了<code>wait()</code></li>
</ul>

<h4>DEAD</h4>

<p>终止状态，是<code>run()</code>执行结束，或因异常退出后的状态，此状态不可逆转。</p>

<h3>如何保证线程安全</h3>

<p>为保证线程安全，在多个线程并发地竞争共享资源时，通常采用同步机制协调各个线程的执行，以确保得到正确的结果。</p>

<p>线程安全的核心理念就是<strong>要么只读，要么加锁</strong>。</p>

<p>保证并发场景下的线程安全，可以从四个维度考量：</p>

<h4>数据单线程内可见</h4>

<p>单线程总是安全的。通过限制数据仅在单线程内可见，可以避免数据被其他线程篡改。最典型的就是线程局部变量，它存储在独立虚拟机栈帧的局部变量表中，与其他线程无关。ThreadLocal 就是采用这种方式来实现线程安全的。</p>

<h4>只读对象</h4>

<p>只读对象总是安全的。它的特性是允许复制、拒绝写入。</p>

<p>最典型的只读对象有String、Integer 等。</p>

<p>一个对象想要拒绝任何写入，必须要满足以下条件：</p>

<ul>
	<li>使用final 关键字修饰类，避免被继承；</li>
	<li>使用private final 关键字避免属性中途被修改；</li>
	<li>没有任何更新方法；</li>
	<li>返回值不能可变对象为引用</li>
</ul>

<h4>线程安全类</h4>

<p>某些线程安全类的内部有非常明确的线程安全机制。</p>

<p>比如StringBuffer 就是一个线程安全类，它采用synchronized 关键字来修饰相关方法。</p>

<h4>同步与锁机制</h4>

<p>如果想要对某个对象进行并发更新操作，但又不属于上述三类，需要开发工程师在代码中实现安全的同步机制。</p>

<p>虽然这个机制支持的并发场景很有价值，但非常复杂且容易出问题。</p>

<h3>Java 并发包</h3>

<p>Java 并发包（Java.util.concurrent，JUC）提高了Java 并发编程的易用性，主要分为几个类族：</p>

<h4>线程同步类</h4>

<p>这些类使线程间的协调更加容易，支持了更加丰富的线程协调场景，逐步淘汰了使用Object 的<code>wait()</code>和<code>notify()</code>进行同步的方式。</p>

<p>主要代表为CountDownLatch、Semaphore、CyclicBarrier 等。</p>

<h4>并发集合类</h4>

<p>集合并发操作的要求是执行速度快，提取数据准。</p>

<p>最著名的类是ConcurrentHashMap，它不断地优化，由刚开始的锁分段到后来的CAS，不断的提升并发性能。</p>

<h4>线程管理类</h4>

<p>虽然Thread 和ThreadLocal 在JDK1.0就已经引入，但真正把Thread 发扬光大的是线程池。</p>

<p>根据实际场景的需要，提供了多种创建线程池的快捷方式，如使用Executors 静态工厂或者使用ThreadPoolExecutor 等。</p>

<h4>锁相关类</h4>

<p>锁以Lock 接口为核心，派生出一些实际场景中进行互斥操作的锁相关类。如ReentrantLock。</p>

<p>锁的很多概念正在弱化，因为锁的实现在各种场景中已经通过类库封装进去了。</p>

<hr />

<h2>什么是锁</h2>

<p>锁主要提供了两种特性：<strong>互斥性</strong>和<strong>不可见性</strong>。</p>

<p>Java 中常用锁实现的方式有两种。</p>

<h3>用并发包中的锁类</h3>

<p>并发包的类族中，<strong>Lock 是JUC 包的顶层接口，它的实现逻辑并未用到synchronized，而是利用了volatile 的可见性</strong>。</p>

<figure><img src="/Users/xerxes/note/java/src/Lock%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png"/></figure>

<p>如上图是Lock 的继承类图，ReentrantLock 对于Lock 接口的实现主要依赖了Sync，而Sync 继承了AbstractQueuedSynchronizer（AQS），它是JUC 包实现同步的基础工具。在AQS 中，定义了一个<code>volatile int state</code>变量作为共享资源，如果线程获取资源失败，则进入同步FIFO 队列中等待；如果成功获取资源就执行临界区代码。执行完释放资源时，会通知同步队列中的等待线程来获取资源后出队并执行。</p>

<p>AQS 是抽象类，内置自旋锁实现的同步队列，封装入队和出队的操作，提供独占、共享、终端等特性的方法。</p>

<h3>利用同步代码块</h3>

<p><strong>同步代码块一般使用Java 的synchronized 关键字来实现</strong>，有两种方式对方法进行加锁操作：</p>

<ul>
	<li>在方法签名处加synchronized 关键字；</li>
	<li>使用<code>synchronized（对象或类）</code>进行同步</li>
</ul>

<p>原则是锁的范围尽可能小，锁的时间尽可能短，即能锁对象就不要锁类，能锁代码块就不要锁方法。</p>

<p><strong>JVM 底层是通过监视锁来实现synchronized 同步的。监视锁即monitor</strong>，是每个对象自带的隐藏字段。使用synchronized 时，JVM 会根据synchronized 的当前使用环境，找到对应对象的monitor，再根据monitor 的状态进行加、解锁的判断。</p>

<hr />

<h2>线程同步</h2>

<p>资源共享的两个原因是资源紧缺和共建需求。</p>

<p>在多个线程对同一变量进行写操作时，如果操作没有原子性，就可能产生脏数据。</p>

<p><strong>线程同步就是线程之间按某种机制协调先后次序执行，当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作</strong>，直到该线程完成操作。</p>

<p>实现线程同步的方式有多种，比如同步方法、锁、阻塞队列等。</p>

<h3>volatile</h3>

<p><strong>可见性是指某线程修改共享变量的指令对其他线程来说都是可见的，它反映的是指令执行的实时透明度</strong>。</p>

<p>Happen before 是时钟顺序的先后，并不能保证线程交互的可见性。</p>

<p><strong>每个线程都有独占的内存区域，线程本地内存保存了引用变量在堆内存中的副本，线程对变量的所有操作都在本地内存区域中进行，之行结束后再同步到堆内存中去</strong>。</p>

<p>这里必然存在一个时间差，在这个时间差内，该线程对副本的操作，对于其他线程都是不可见的。</p>

<p><strong>当使用volatile 关键字修饰变量时，意味着任何对此变量的操作都会在内存中进行，不会产生副本，以保证共享变量的可见性</strong>。</p>

<h3>信号量同步</h3>

<p><strong>信号量同步是指在不同的线程之间，通过传递同步信号量来协调线程执行的先后顺序</strong>。</p>

<hr />

<h2>线程池</h2>

<h3>线程池的好处</h3>

<p>线程的创建需要开辟虚拟机栈、本地方法栈、程序计数器等线程私有的内存空间。销毁时需要回收这些系统资源。</p>

<p>频繁地创建和销毁线程会浪费大量的系统资源，增加并发编程风险。</p>

<p>线程池的作用包括：</p>

<ul>
	<li>利用线程池管理并复用线程、控制最大并发数等；</li>
	<li>实现任务线程队列缓存策略和拒绝机制；</li>
	<li>实现某些与时间相关的功能，如定时执行、周期执行等；</li>
	<li>隔离线程环境，为不同服务配置不同的线程池</li>
</ul>

<hr />

<h2>ThreadLocal</h2>

<p>ThreadLocal 设计初衷是在线程并发时，解决变量共享问题。但由于过度设计，如弱引用和哈希碰撞，导致理解难度大、使用成本高，反而称为问题高发点，容易出现内存泄漏、脏数据、共享对象更新等问题。</p>

<h3>引用类型</h3>

<p>对象在堆上创建之后持有的引用其实是一种变量类型，引用之间可以通过赋值构成一条引用链。从GC Roots 开始遍历，判断引用是否可达。引用的可达性是判断能否被垃圾回收的基本条件。</p>

<p>某些场景下，即使引用可达，也希望能够根据语义的强弱进行有选择的回收。</p>

<p>根据引用类型语义的强弱来决定垃圾回收的阶段，可以把引用分为强引用、软引用、弱引用和虚引用四类。</p>

<figure><img src="/Users/xerxes/note/java/src/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.png"/></figure>

<h4>强引用Strong Reference</h4>

<p>如<code>Object object = new Object();</code>，这样的变量声明和定义就会产生对该对象的强引用，只要对象有强引用指向，并且GC Roots 可达，那么GC 时即使濒临内存耗尽，也不会回收该对象。</p>

<h4>软引用Soft Reference</h4>

<p>用在非必须对象的场景。</p>

<p>在即将OOM 之前，GC Collector 会把这些软引用指向的对象加入回收范围，以获得更多的内存空间。</p>

<p>主要用来缓存服务器中间计算结果及不需要实时保存的用户行为等。</p>

<h4>弱引用Weak Reference</h4>

<p>也用来描述非必须对象。</p>

<p>如果弱引用指向的对象只存在弱引用这一条路线，则下一次YGC 时会被回收。</p>

<p>主要用于指向某个易消失的对象，在强引用断开后，此引用不会劫持对象。</p>

<h4>虚引用Phantom Reference</h4>

<p>极弱的一种引用关系，定义完成后，就无法通过该引用获取指向的对象。</p>

<p>为一个对象设置虚引用的唯一目的就是希望能在这个对象被回收时收到一个系统通知。</p>

<p>虚引用必须与引用队列联合使用，当GC 时，如果发现存在虚引用，就会在回收对象内存前，把这个虚引用加入与之关联的引用队列中。</p>

</body>
</html>

