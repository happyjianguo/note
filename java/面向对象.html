<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>面向对象</title>
	</head>
<body>
<h1>面向对象</h1>

<hr />

<h2>OOP 理念</h2>

<p>面向对象有四大特性：</p>

<ul>
	<li>抽象：抽象是程序员的核心素质之一，体现出程序员对业务的建模能力，以及对架构的宏观掌控力；</li>
	<li>封装：封装是一种对象功能内聚的表现形式，使模块之间耦合度变低，更具有维护性；</li>
	<li>继承：继承使子类能够继承父类，获得父类的部分属性和行为，使模块更有复用性；</li>
	<li>多态：多态使模块在复用性基础上更加有扩展性，使运行期更有想象空间</li>
</ul>

<h3>抽象</h3>

<p>抽象是面向对象思想最基础的能力之一，正确而严谨的业务抽象和建模分析能力是后续的封装、继承、多态的基础。</p>

<p>在面向对象的思维中，抽象分为归纳和演绎：</p>

<ul>
	<li>前者是从具体到本质，从个性到共性，将一类对象的共同特征进行归一化的逻辑思维过程。归纳过程中，需要<strong>抽象出对象的属性和行为的共性</strong>；</li>
	<li>后者是从本质到具体，从共性到个性，逐步形象化的过程。是在已有问题解决方案的基础上，正确地找到合适的使用场景</li>
</ul>

<h3>封装</h3>

<p>封装是在抽象基础上决定信息是否公开，以及公开等级，核心问题是以什么样的方式暴露哪些信息。</p>

<p>抽象过程中找到了属性和行为的共性，属性是行为的基本生产资料，具有一定敏感性，不能直接对外暴露。因此封装的主要任务是<strong>对属性、数据、部分内部敏感行为实现隐藏</strong>。</p>

<p>对属性的访问与修改必须通过定义的公共接口来进行，某些敏感方法或者外部不需要感知的复杂逻辑处理，一般也会进行封装。</p>

<p>设计模式七大原则之一的迪米特法则就是对于封装的具体要求：A 模块使用B 模块的某个接口行为，对B 模块中除此行为之外的其他信息知道的尽可能少。</p>

<p>这使模块之间的协作只需忠于接口、忠于功能实现即可。</p>

<h3>继承</h3>

<p><strong>继承允许创建具有逻辑等级结构的类体系，形成一个继承树</strong>，让软件在业务多变的客观条件下，某些基础模块可以被直接复用、间接复用或增强复用，父类的能力通过这种方式赋予子类。</p>

<p>继承是is-a关系，衡量当前的继承关系是否满足is-a关系的判断标准即：是否符合<strong>里氏代换原则（Liskov Substitution Principle，LSP）</strong>。</p>

<p>LSP 是指任何父类能够出现的地方，子类都能够出现。</p>

<p><strong> 子类继承父类，说明子类对象可以调用父类对象的一切行为</strong>。</p>

<p>实际代码环境中，如果直接使用子类引用代替父类引用，可以编译并正确执行，输出结果符合子类场景的预期，那么说明两个类之间符合LSP 原则，可以使用继承关系。</p>

<h4>谨慎使用继承</h4>

<p>谨慎使用继承，认清继承滥用的危害性，即<em>方法污染</em>和<em>方法爆炸</em>。</p>

<p>方法污染是指父类具备的行为，通过继承传递给子类，子类并不具备执行此行为的能力。</p>

<p>方法爆炸是指继承树不断扩大，底层类拥有的方法虽然能够执行，但是由于方法众多，其中部分方法并非与当前类的功能定位相关。</p>

<p>提倡组合优先原则来扩展类的能力，即<strong>优先采用组合或聚合的类关系来复用其他类的能力，而不是继承</strong>。</p>

<h3>多态</h3>

<p>多态是以上述的三个面向对象特性为基础，<strong>根据运行时的实际对象类型，同一个方法产生不同的运行结果，使同一个行为具有不同的表现形式</strong>。</p>

<h4>override &amp; overload</h4>

<p>Override 为覆写，是子类实现接口，或者继承父类时，保持方法签名完全相同，实现不同的方法体。</p>

<p>Overload 为重载，方法名称相同，但是参数类型或者参数个数不相同。</p>

<p><strong>多态是指在编译层面无法确定最终调用的方法体，以覆写为基础来实现面向对象特性，在运行期由JVM 进行动态绑定，调用合适的覆写方法来执行</strong>。</p>

<p>重载是编译期确定方法调用，属于静态绑定。</p>

<hr />

<h2>类</h2>

<h3>类的定义</h3>

<p>类的定义由访问级别、类型、类名、是否抽象、是否静态、范型标识、继承或实现关键字、父类或接口名称等组成。</p>

<p>Java 类主要由两部分组成：成员和方法。</p>

<h3>接口与抽象类</h3>

<p>正如面向对象的四大特性所述，定义类的过程就是抽象和封装的过程，而接口与抽象类则是对<strong>实体类进行更层次的抽象，仅定义公共行为和特征</strong>。</p>

<p><strong>接口和抽象类都不能被实例化</strong>，但可以定义引用变量指向实例对象。</p>

<p>如下图所示是接口与抽象类的语法区别：</p>

<figure><img src="/Users/xerxes/note/computerOrganization/src/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%AF%AD%E6%B3%95%E5%8C%BA%E5%88%AB.png"/></figure>

<p><strong>抽象类在被继承时体现的是is-a关系，接口在被实现时体现的是can-do关系</strong>。</p>

<p>Is-a关系需要符合里氏代换原则，can-do关系要符合接口隔离原则，实现类要有能力去实现并执行接口中定义的行为。</p>

<p><strong>抽象类是模版式设计，而接口是契约式设计</strong>。</p>

<p>接口是顶级的类，虽然关键字是interface，但是编译之后的字节码扩展名还是<code>.class</code>。抽象类是二当家，接口位于顶层，而抽象类对各个接口进行了组合，然后实现部分接口行为，如AbstractCollection 是最典型的抽象类：</p>

<pre><code>public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; {
    public abstract int size();
    public boolean isEmpty() {
        return size() == 0;
    }
}
</code></pre>

<p>Java 中类的继承采用单继承形式，避免继承泛滥、菱形继承、循环继承。</p>

<p>在JVM 中，一个类如果有多个直接父类，那么方法的绑定机制会很复杂。接口继承接口，关键字是extends，而不是implements，允许多重继承，是因为接口有契约式的行为绑定，没有任何具体实现和属性。</p>

<p>当纠结定义接口还是抽象类时，优先推荐定义为接口，遵循接口隔离原则，按某个维度划分成多个接口，然后再用抽象类去implements 某些接口，方便后续的扩展和重构。</p>

<h3>内部类</h3>

<p>一个<code>.java</code>源文件中，只能定义一个类名与文件名完全一致的公开类，使用<code>public class</code>关键字来修饰。</p>

<p><strong>任何一个类都可以在内部定义另外一个类，前者为外部类，后者为内部类</strong>。内部类本身就是类的一个属性，与其他属性定义方式一致。</p>

<p>内部类可以是静态或非静态的，可以出现在属性定义、方法体和表达式中，甚至可以匿名出现，具体分为四种；</p>

<ul>
	<li>静态内部类</li>
	<li>成员内部类</li>
	<li>局部内部类</li>
	<li>匿名内部类</li>
</ul>

<pre><code>public class OuterClass {
    // 成员内部类
    private class InstanceInnerClass {}
    // 静态内部类
    static class StaticInnerClass {}

    public static void main(String[] args) {
        // 两个匿名内部类
        (new Thread() {}).start();
        // 方法内部类
        class MethodClass1 {}
    }
}
</code></pre>

<p>无论是什么类型的内部类，都会编译成一个独立的<code>.class</code>文件。外部类与内部类之间使用<code>$</code>符号分隔，匿名内部类使用数字进行编号，方法内部类在类名前还有一个编号来标识是哪个方法。</p>

<p>静态内部类是最常用的内部表现形式，类加载与外部类在同一个阶段进行，其好处是：</p>

<ul>
	<li>包内可见，作用域不会扩散到包外；</li>
	<li>可以通过<code>OuterClass.StaticInnerClass</code>的方式直接访问；</li>
	<li>内部类可以访问外部类中的所有静态属性和方法</li>
</ul>

<h3>访问权限控制</h3>

<p>访问权限控制符可以用来限制类外部对类内属性和方法的随意访问。</p>

<figure><img src="/Users/xerxes/note/java/src/%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.png"/></figure>

<p>如上图是Java 中访问权限控制及可见范围。</p>

<p>定义类时，推荐访问控制级别从严处理：</p>

<ul>
	<li>如果不允许外部直接通过new 创建对象，构造方法必须是private；</li>
	<li>工具类不允许有public 或default 构造方法；</li>
	<li>类非static 成员变量并且与子类共享，必须是protected；</li>
	<li>类非static 成员变量并且尽在本类使用，必须是private；</li>
	<li>类static 成员变量如果仅在本来使用，必须是private；</li>
	<li>若是static 成员变量，必须考虑是否为final；</li>
	<li>类成员方法只供内部调用，必须是private；</li>
	<li>类成员方法只对继承类公开，限制为protected</li>
</ul>

<h3>this 与super</h3>

<p>对象实例化时，至少有一条从本类出发抵达Object 的通路，打通此路的方式就是this 和super。</p>

<p>This 和super 很多情况下可以省略：</p>

<ul>
	<li>本类方法调用本类属性；</li>
	<li>本类方法调用另一个本类方法；</li>
	<li>子类构造方法隐含调用<code>super()</code></li>
</ul>

<p>任何类在创建之初，都有一个默认的空构造方法，它是<code>super()</code>的一条默认通路。</p>

<p>构造方法的参数列表决定了调用通路的选择：</p>

<ul>
	<li>如果子类指定调用父类的某个构造方法，super 就会不断往上溯源；</li>
	<li>如果没有指定，则默认调用<code>super()</code>；</li>
	<li>如果父类没有提供默认的构造方法，子类在继承时就会编译错误；</li>
	<li>如果父类坚持不提供默认的无参构造方法，必须在本类的无参构造方法中使用super 方式调用父类的有参构造方法，如<code>public Son() {super(123);}</code></li>
</ul>

<p>如果this 和super 指代构造方法，则必须位于方法体的第一行。也就是说<strong>在一个构造方法中，this 和super 只能出现一个，且只能出现一次</strong>，否则在实例化对象时，会因子类调用到多个父类构造方法而造成混乱。</p>

<p>由于<strong>this 和super 都在实例化阶段调用</strong>，所以不能在静态方法和静态代码块中使用this 和super 关键字。</p>

<p>This 还可以指代当前对象，比如在同步代码块<code>synchronized(this){...}</code>中，super 不具备此能力。</p>

<figure><img src="/Users/xerxes/note/java/src/this%E5%92%8Csuper%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9.png"/></figure>

<h3>类关系</h3>

<p>证明类之间没关系是一个涉及业务、架构、模块边界的问题，往往由于业务模型的抽象角度不同而不同，找到了没有关系的点，就可以进行架构隔离、模块解耦等工作。</p>

<p>有关系的情况分为五种：</p>

<ul>
	<li>继承：extends（is-a）</li>
	<li>实现：implements（can-do）</li>
	<li>组合：类是成员变量（contains-a）。类关系中的组合是一种完全绑定的关系，所有成员共同完成一件使命，它们的生命周期一样；</li>
	<li>聚合：类是成员变量（has-a）。聚合是一种可以拆分的整体与部分的关系，部分可以被拆出来给另一个整体</li>
	<li>依赖：import（use-a）。依赖是除组合和聚合外的类与类之间的关系，这个类只要import，就是依赖关系</li>
</ul>

<h3>序列化</h3>

<blockquote>
<p>内存中的数据对象只有转换为二进制流才可以进行数据持久化和网络传输。</p>
</blockquote>

<p>将数据对象转换为二进制流的过程称为对象的<strong>序列化（Serialization）</strong>。反正将二进制流恢复为数据对象的过程称为<strong>反序列化（Deserialization）</strong>。</p>

<p>序列化需要保留充分的信息以恢复数据对象，但是为了节约存储空间和网络带宽，序列化后的二进制流要尽可能小。常见的使用场景是RPC 框架的数据传输。</p>

<p>常见的序列化方式有三种：Java 原生序列化，Hessian 序列化和JSON 序列化。</p>

<h4>Java 原生序列化 </h4>

<p>Java 类通过实现Serializable 接口来实现该对象的序列化，该接口没有任何方法，只起标识作用。</p>

<p>Java 序列化保留了对象类的元数据（如类、成员变量、继承类信息等），以及对象数据等。</p>

<p>该方法兼容性最好，但不支持跨语言，而且性能一般。</p>

<p>实现Serializable 接口类建议设置serialVersionUID 字段值，如果不设置，每次运行时编译器会根据类的内部实现，包括类名、接口名、方法和属性等来自动生成serialVersionUID。如果类被修改了，重新编译后serialVersionUID 的值可能会变。</p>

<p>因此实现Serializable 接口的类一定要显式地定义serialVersionUID，修改类时需要根据兼容性决定是否修改serialVersionUID：</p>

<ul>
	<li>如果兼容升级，不要修改serialVersionUID，避免反序列化失败；</li>
	<li>如果不兼容升级，需要修改serialVersionUID，避免反序列化混乱</li>
</ul>

<h4>Hessian 序列化</h4>

<p>Hessian 序列化是一种支持动态类型、跨语言、基于对象传输的网络协议。具体特性如下：</p>

<ul>
	<li>自描述序列化类型，不依赖外部描述文件或接口定义，用一个字节表示常用基础类型，极大缩短二进制流；</li>
	<li>语言无关，支持脚本语言；</li>
	<li>协议简单，比Java 原生序列化高效</li>
</ul>

<p>Hessian 会把复杂对象所有属性存储在一个Map 中进行序列化。所以在父类、子类存在同名成员变量时，Hessian 序列化先序列化子类，然后序列化父类，因此反序列化结果会导致子类同名成员变量被父类的值覆盖。</p>

<h4>JSON 序列化</h4>

<p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。</p>

<p>JSON 序列化就是将数据对象转换为JSON 字符串。在序列化过程中抛弃了类型信息，所以反序列化时只有提供类型信息才能准确地反序列化。</p>

<h4>序列化防攻击</h4>

<p>序列化通常会通过网络传输对象，而对象中往往有敏感数据，攻击者可以利用反序列化过程构造恶意代码，使程序在反序列化的过程中执行任意代码。</p>

<p>有些对象的敏感属性不需要进行序列化传输，可以加<code>transient</code>关键字，避免把此属性转化为序列化的二进制流。</p>

<p>如果一定要传递对象的敏感属性，可以使用对称与非对称加密方式独立传输，再使用某个方法把属性还原到对象中。</p>

<hr />

<h2>方法</h2>

<h3>方法签名</h3>

<p><strong>方法签名包括方法名称和参数列表，是JVM 标识方法的唯一索引</strong>，不包括返回值，更加不包括访问权限控制符、异常类型等。</p>

<h3>参数</h3>

<p>参数在方法中，属于方法签名的一部分，包括参数类型和参数个数。</p>

<p>形参在方法定义阶段，而实参是在方法调用阶段。</p>

<p><strong>无论是基本数据类型还是引用变量，Java 中的参数传递都是值复制的传递过程。对于引用变量，复制指向对象的首地址</strong>。</p>

<p>方法的第一步骤并不是功能实现，而应该是参数预处理，参数预处理有两种：</p>

<ul>
	<li>入参保护：入参保护实质上是对服务提供方的保护，比如对入参的数据量进行判断和控制；</li>
	<li>参数校验：基于防御式编程理念，在方法内要对方法调用方传入的参数进行必要的检测。但由于方法间交互频繁，所有方法都进行参数校验会导致重复代码及不必要的检查影响代码性能</li>
</ul>

<h3>构造方法 Constructor</h3>

<p><strong>构造方法是方法名与类名相同的特殊方法，在新建对象时调用，可以通过不同的构造方法实现不同方式的对象初始化</strong>。</p>

<p>其特征有：</p>

<ul>
	<li>构造方法名称必须与类名相同；</li>
	<li>构造方法是没有返回类型的，即使是void 也不能有。它返回对象的地址，并赋值给引用变量；</li>
	<li>构造方法不能被继承，不能被覆写，不能被直接调用。调用途径有三种：

		<ul>
			<li>通过new 关键字；</li>
			<li>在子类的构造方法中通过super 调用父类的构造方法；</li>
			<li>通过反射方式获取并使用</li>
		</ul></li>
	<li>类定义时提供了默认的无参构造方法。如果显式定义了有参构造方法，则此无参构造方法会被覆盖。如果依然想拥有，就需要进行显式定义；</li>
	<li>构造方法可以私有。外部无法使用私有构造方法创建对象；</li>
	<li>接口中不能定义构造方法；抽象类中可以定义；枚举类中可以定义，但是默认是private 的，不能加public，是绝对的单例，不允许外部以创建对象的方式生成枚举类型；</li>
	<li>一个类可以有多个参数不同的构造方法，称为构造方法的重载</li>
</ul>

<p>构造方法的使命就是在构造对象时进行传参操作，不应该在构造方法中引入业务逻辑。</p>

<p><strong>类中的<code>static {...}</code>代码称为类的静态代码块，在类初始化时执行，优先级高</strong>。</p>

<p>以下面的代码为例：</p>

<pre><code>class Son extends Parent {
    static {System.out.println(&quot;Son static code block&quot;);}
    Son() {System.out.println(&quot;Son Constructor&quot;);}

    public static void main(String[] args) {
        new Son();
        new Son();
    }
}

class Parent {
    static {System.out.println(&quot;Parent static code block&quot;);}
    public Parent() {System.out.println(&quot;Parent Constructor&quot;);}
</code></pre>

<p>执行结果：</p>

<pre><code>Parent static code block
Son static code block
Parent Constructor
Son Constructor
Parent Constructor
Son Constructor
</code></pre>

<p><strong>在创建类对象时，会先执行父类和子类的静态代码块，然后执行父类和子类的构造方法</strong>。</p>

<p><strong>静态代码块只运行一次，在第二次对象实例化时，不会运行</strong>。</p>

<h3>类内方法</h3>

<h4>实例方法（非静态方法）</h4>

<p>必须依附于某个实际对象，可以通过引用变量调用其方法。</p>

<p>类内部各个实例方法之间可以互相调用，也可以直接读写类内变量，但是不包含this。</p>

<p><strong>当<code>.class</code>字节码文件加载之后，实例方法并不会被分配方法入口地址，只有在对象创建之后才会被分配</strong>。</p>

<p>实例方法可以调用静态变量和静态方法，当从外部创建对象后，应尽量使用“类名.静态方法”来调用，而不是对象名。一来为编译器减负，而来提升代码可读性。</p>

<h4>静态方法（类方法）</h4>

<p><strong>当类加载后，即分配了相应的内存空间</strong>。</p>

<p>由于生命周期的限制，使用静态方法需要注意两点：</p>

<ul>
	<li>静态方法中不能使用实例成员变量和实例方法；</li>
	<li>静态方法不能使用super 和this 关键字，这两个关键字指代的都是需要被创建出来的对象</li>
</ul>

<p>静态方法通常用于定义工具类的方法。静态方法如果使用了可修改的对象，那么在并发时会存在线程安全问题。因此工具类的静态方法与单例通常相伴。</p>

<h4>静态代码块</h4>

<p><strong>静态代码块在类加载时调用一次，且只执行一次，且先于构造方法执行</strong>。</p>

<p>实际应用中例如容器初始化，可以使用静态代码块实现类加载判断、属性初始化、环境配置等。</p>

<p>很多容器框架会在单例对象初始化成功后调用默认<code>init()</code>方法，完成例如RPC 注册中心服务器判断、应用通用底层数据初始化等工作。如下代码所示：</p>

<pre><code>public class RpcProviderBean {
    public void init() throws RpcRuntimeException {
        this.initRegister();
        this.publish();
     }
    public void initRegister() {
        if (this.inited.compareAndSet(false, true)) {
            this.checkConfig();
            this.metadata.init();
        }
    }
public void publish() {
        // 将本地服务信息发送到注册中心
    }
}
</code></pre>

<h3>getter 和setter</h3>

<p>Getter 和setter 方法是一类特殊的实例方法，一般不包含业务逻辑，仅仅是<strong>为类成员属性提供读取和修改的方法</strong>，这样设计有两点好处：</p>

<ul>
	<li>满足面向对象语言封装的特性。尽可能将类中的属性定义为private，针对属性值的访问和修改使用相应的getter 和setter 方法，而不是直接对public 的属性进行读取和修改；</li>
	<li>有利于统一控制：虽然直接对属性进行读取、修改的方式和使用相应的getter 和setter 方法在效果上一样，但前者难以应对业务的变化。例如业务要求对某个属性值的修改增加统一的权限控制，如果有setter 作为统一的属性修改方法会更容易实现（这种情况在一些使用反射的框架中作用尤其明显）</li>
</ul>

<p>最典型的getter 和setter 方法使用是在POJO（Plain Ordinary Java Object，简单的Java 对象）类中。</p>

<p>POJO 专指只包含getter、setter、toString 方法的简单类，POJO 作为数据载体，通常用于数据传输，不包含任何业务逻辑。</p>

<h3>同步与异步</h3>

<p>同步调用是刚性调用，是阻塞式操作，必须等待调用方法执行结束。</p>

<p>而异步调用是柔性调用，是非阻塞式操作，在执行过程中，如调用其他方法，自己可以继续执行而不被阻塞等待方法调用完毕。</p>

<h3>覆写</h3>

<p>如果父类定义的方法达不到子类的期望，那么子类可以重新实现方法覆盖父类的实现。</p>

<p>因为有些子类是延迟加载的，甚至是网络加载的，所以最终的实现需要在运行期判断，也就是所谓的动态绑定。</p>

<p>动态绑定是实现多态的重要因素，元空间有一个方法表保存着每个可以实例化类的方法信息，JVM 可以通过方法表快速的激活实例方法。</p>

<p>如果某个类覆写了父类的某个方法，则方法表中的方法指向引用会指向子类的实现处。</p>

<p>如下代码是一个调用子类方法的方式：</p>

<pre><code>Father father = new Son();
father.doSomething()；
</code></pre>

<p>这称为向上转型，通过父类引用子类方法时需要注意两点：</p>

<ul>
	<li>无法调用子类中存在而父类本身不存在的方法；</li>
	<li>可以调用到子类中覆写了父类的方法，这是一种多态实现</li>
</ul>

<p>想成功覆写父类方法，需要四个条件：</p>

<ul>
	<li>访问权限不能变小；</li>
	<li>返回类型能够向上转型成为父类的返回类型：在覆写时父类的方法表指向了子类实现方法，编译器会检查返回值是否想上兼容。这里的向上转型必须是严格的继承关系；</li>
	<li>异常也要能向上转型成为父类的异常：异常分为checked 和unchecked 两种类型。如果父类抛出一个checked 异常，则子类只能抛出此异常或它的子类。unchecked 则不需要；</li>
	<li>方法名、参数类型及个数必须严格一致：为了使编译器准确地判断是否是覆写行为，所有的覆写方法必须加<code>@Override</code>注解。此时编译器会自动检查覆写方法签名是否一致，避免了覆写时因写错而导致覆写失败</li>
</ul>

<p>覆写只能针对非静态、非final、非构造方法。</p>

<hr />

<h2>重载</h2>

<p>在同一个类中，如果多个方法有相同的名字、不同的参数，即称为重载。</p>

<p>JVM 在重载方法中，选择合适的目标方法的顺序是：</p>

<ol>
	<li>精确匹配；</li>
	<li>如果是基本数据类型，自动转换成更大表示范围的基本类型；</li>
	<li>通过自动拆箱与装箱；</li>
	<li>通过子类向上转型继承路线依次匹配；</li>
	<li>通过可变参数匹配</li>
</ol>

<p>父类的公有实例方法与子类的公有实例方法可以存在重载关系。不管继承关系如何复杂，重载在编译时可以根据规则知道调用哪种目标方法。所以重载又称为<strong>静态绑定</strong>。</p>

<hr />

<h2>泛型</h2>

<p><strong>泛型的本质是类型参数化，解决不确定具体对象类型的问题</strong>。</p>

<p>在面向对象编程语言中，允许在强类型校验下定义某些可变部分，以达到代码复用的目的。</p>

<p>Java 在引入泛型之前，如果要定义不确定具体参数类型的方法，需要将参数和返回值定义为Object，然后进行向上转型。这样在取出返回值时进行强制类型转换就会存在类型转换风险。</p>

<p>泛型可以定义在类、接口、方法中，编译器通过<code>&lt;&gt;</code>来解析泛型。泛型定义时，约定：</p>

<ul>
	<li>E：Element，用于集合中的元素；</li>
	<li>T：the Type of object，表示某个类；</li>
	<li>K：Key</li>
	<li>V：Value</li>
</ul>

<p>泛型有以下几点特性：</p>

<ul>
	<li><code>&lt;&gt;</code>内的每个元素都指代一种未知类型；</li>
	<li><code>&lt;&gt;</code>的位置必须在类名之后或方法返回值之前；</li>
	<li>泛型在定义处只具备Object 方法的能力；</li>
	<li>泛型只是一种编写代码时的语法检查，在使用泛型元素时，会执行强制类型转换，即类型擦除。因此泛型就是在编译器增加了一道检查，目的是促使程序员在使用泛型时安全放置和使用数据</li>
</ul>

<p>使用泛型的好处包括：</p>

<ul>
	<li>类型安全；</li>
	<li>提升可读性；</li>
	<li>代码重用</li>
</ul>

<hr />

<h2>数据类型</h2>

<h3>基本数据类型</h3>

<p>Java 提供了九种基本数据类型，它们不具备对象的特性，没有属性和行为。</p>

<p>基本数据类型是指不可再分的院子数据类型，内存中直接存放这种类型的值。</p>

<p>九种基本数据类型包括boolean、byte、char、short、int、long、float、double、refvar。</p>

<p>前八种数据类型表示生活中的真假、字符、整数和小数，最后一种refvar 是面向对象世界中的引用变量，也叫引用句柄。</p>

<p>前八种都有相应的包装数据类型。这八种基本数据类型的默认值、空间占用大小、表示范围及对应的包装类等信息如下表所示：</p>

<figure><img src="/Users/xerxes/note/java/src/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"/></figure>

<p>如下图所示，对象分为三块存储区域：</p>

<figure><img src="/Users/xerxes/note/java/src/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8.png"/></figure>

<h4>对象头（Object Header）</h4>

<p>对象头占用12个字节，存储内容包括对象标记（markOop）和类元信息（KlassOop）。</p>

<p>对象标记存储对象本身运行时的数据，如哈希码、GC 标记、锁信息、线程关联信息等，这部分数据在64位JVM 上占用8个字节，称为‘Mark Word’。为了存储更多的状态信息，对象标记的存储格式是非固定的。</p>

<p>类元信息存储的是对象指向它的类元数据（即Klass）的首地址，占用4个字节，与refvar 开销一致。</p>

<h4>实例数据（Instance Data）</h4>

<p>存储本类对象的实例成员变量和所有可见的父类成员变量。</p>

<h4>对齐填充（Padding）</h4>

<p>对象的存储空间分配单位是8个字节，如果一个占用大小为16个字节的对象，增加一个成员变量byte 类型，此时需要占用17个字节，但是也会分配24个字节进行对齐填充。</p>

<h3>包装类型</h3>

<p>包装类的存在解决了基本数据类型无法做到的事情：范型类型参数、序列化、类型转换、高频区间数据缓存。</p>

<p>以数据缓存为例，Integer 会缓存-128～127之间的值，对于<code>Integer var = ？</code>在-128～127之间的赋值，Integer 对象由<code>IntegerCache.cache</code>产生，会复用已有对象，这个区间内的Integer 值可以直接使用<code>==</code>进行判断，但是这个区间之外的所有数据都会在堆上产生，并不会复用已有对象。因此推荐<strong>所有包装类对象之间值的比较，全部使用<code>equals()方法</code></strong>。</p>

<p>除Float 和Double 外，其他包装数据类型都会缓存，6个包装类直接赋值时，会调用对应包装类的静态工厂方法<code>valueOf()</code>，以Integer 的源码为例：</p>

<pre><code>@HotSpotIntrinsicCandidate
public static Integer valueOf(int i) {
    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
</code></pre>

<p>在JDK9中直接把new 的构造方法过时，推荐使用<code>valueOf()</code>，合理使用缓存，提升程序性能。</p>

<p>在选择使用包装类还是基本数据类型时，推荐使用如下方式：</p>

<ul>
	<li>所有的POJO 类属性必须使用包装数据类型；</li>
	<li>RPC 方法的返回值和参数必须使用包装数据类型；</li>
	<li>所有的局部变量推荐使用基本数据类型</li>
</ul>

<h3>字符串</h3>

<p>字符串相关类型主要有三种：String、StringBuilder、StringBuffer。</p>

<p>String 是只读字符串，典型的immutable 对象，对它的任何改动都是创建一个新对象，再把引用指向该对象。</p>

<p>String 对象赋值操作后，会在常量池中进行缓存，如果下次申请创建对象时，缓存中已经存在，则直接返回相应引用给创建者。</p>

<p>而StringBuffer 则可以在原对象上进行修改，是线程安全的。</p>

<p>JDK5引入的StringBuilder 和StringBuffer 均继承自AbstractStringBuilder，两个子类的很多方法都是通过<code>super.method()</code>的方式调用抽象父类中的方法，此抽象类在内部与String 一样，也是以字符数组的形式存储字符串的。</p>

<p>StringBuilder 是非线程安全的，把是否需要进行多线程加锁交给程序员决定，操作效率比StringBuffer 高。</p>

<p>在非基本数据类型的对象中，String 是仅支持直接相加操作的对象。在循环体内如果使用这种方式：</p>

<pre><code>String str = &quot;start&quot;;
for (int i=0; i&lt;100; i++) {
    str = str + &quot;hello&quot;;
}
</code></pre>

<p>每次循环都会new 一个StringBuilder 对象，然后进行append 操作，最后通过<code>toString</code>方法返回String 对象。因此应该使用StringBuilder 的append 方法。</p>

</body>
</html>

