<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta charset="utf-8" />
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<title>概览</title>
	</head>
<body>
<h1>概览</h1>

<hr />

<h2>基本概念和原理</h2>

<h3>索引结构</h3>

<p><strong>es是面向文档的</strong>。各种文本内容以文档的形式存储在es中，一般使用JSON作为文档的序列化格式，文档可以有很多字段，在创建索引时，需要描述文档中每个字段的数据类型。</p>

<p><strong>在存储结构上，由索引-类型-ID唯一确定es的一个文档</strong>。</p>

<p>索引指向一个或多个物理分片的逻辑命名空间；类型用于区分同一个集合中的不同细分，不同细分中数据的整体模式是相同或类似的，不适合完全不同类型的数据。多个类型可以在相同的索引中存在，只要字段不冲突（对于整个索引，映射在本质上被“扁平化”成一个单一的、全局的模式）；ID文档标记符由系统自动生成或使用者提供。</p>

<h3>文档</h3>

<p>文档是索引和搜索数据的最小单位。文档有几个重要的属性。</p>

<ul>
	<li>自我包含：一篇文档同时包含字段和它们的取值</li>
	<li>可以是层次型的：字段的取值可以是简单的字符串，也可以包含其他的字段和取值</li>
	<li>拥有灵活的结构：不依赖于预先定义的模式</li>
</ul>

<h3>类型</h3>

<p>在不同的类型中，最好放入不同结构的文档。</p>

<p>每个类型中字段的定义称为映射，每种字段都是通过不同的方式进行处理。</p>

<p>映射包含了某个类型中当前索引的所有文档的所有字段。最好在索引数据之前，就定义好所需的映射。</p>

<p>映射类型只是将文档进行逻辑划分。从物理角度来看，同一索引中的文档都是写入磁盘，而不考虑所属的映射类型。</p>

<h3>分片（shard）</h3>

<p>es将数据副本分为主从两部分，即<strong>主分片和副分片</strong>。主数据作为权威数据，写过程先写主分片，成功后再写副分片，恢复阶段以主分片为主。</p>

<p>分片是底层的基本读写单元，分片的目的是分割巨大索引，让读写可以并行操作，由多台机器共同完成。读写请求最终落到某个分片上，分片可以独立执行读写工作。</p>

<p>Es利用分片将数据分发到集群各个节点，当集群规模扩大或缩小时，es会自动在各节点中迁移分片，使数据仍然均匀分布在集群中。</p>

<p>分片是数据的容器，文档保存在分片内，不会跨分片存储。</p>

<figure><img src="/Users/xerxes/note/elasticsearch/src/%E7%B4%A2%E5%BC%95%E5%92%8C%E5%88%86%E7%89%87.jpg"/></figure>

<p><strong>一个es索引包含很多分片，一个分片是一个Lucene的索引，Lucene由很多分段组成，每个分段都是一个倒排索引</strong>。</p>

<p>es每次refresh都会生成一个新的分段，其中包含若干文档的数据。<strong>在每个分段内，文档的不同字段被单独建立索引。每个字段的值由若干词（Term）组成</strong>，Term是原文本内容经过分词器处理和语言处理后的最终结果。</p>

<p>索引建立的时候就需要确定好主分片数。</p>

<p>实际应用中，不应该向单个索引持续写数据，应该周期性地创建新索引。<strong>巨大的索引会在数据老化后难以删除。删除文档不会立刻释放空间，删除的文档只在Lucene分段合并时才会真正从磁盘中删除</strong>。即使手工触发分段合并，仍然会引起较高的I/O压力，并且可能因为分段巨大导致在合并过程中磁盘空间不足。</p>

<p>索引别名类似一个快捷方式或软链接，不同的是它可以指向一个或多个索引。可以用于实现索引分组，或者索引间的无缝切换。</p>

<h3>动态更新索引</h3>

<p>为文档建立索引，使其每个字段都可以被搜索，通过关键词检索文档内容，会使用倒排索引的数据结构。倒排索引一旦被写入文件后就具有不变性，好处在于对文件的访问不需要加锁，读取索引时可以被文件系统缓存。</p>

<p>由于分段（倒排索引）的不变性，更新、删除等操作实际上是将数据标记为删除，记录到单独的位置，称为标记删除。因此删除部分数据不会释放磁盘空间。</p>

<p>为了让新添加的文档可以被搜索到，es使用更多的索引，新增内容并写到一个新的倒排索引中，查询时，每个倒排索引都被轮流查询，查询完再对结果进行合并。</p>

<h3>近实时搜索</h3>

<p>在写操作中，一般会先在内存中缓冲一段数据，es每秒清空一次写缓冲，再将这些数据写入磁盘，这个过程称为refresh，每次写入磁盘的这批数据成为一个新的Lucene分段。在一个记录元信息的文件中描述了当前Lucene索引都含有哪些分段。</p>

<p>一般情况下（direct方式除外）通过操作系统write接口写到磁盘的数据先到达系统缓存，write函数返回成功时，数据未必被刷到磁盘。通过手工调用flush，或者操作系统通过一定策略将系统缓存刷到磁盘。这种策略大幅提升了写入效率。<strong>从write函数返回成功开始，无论数据有没有被刷到磁盘，该数据已经对读取可见</strong>。</p>

<p>由于系统先缓冲一段数据才写，且新段不会立即刷入磁盘，为了防止数据丢失，通用的做法是记录事务日志，当es启动时，重放translog中所有在最后一次提交后发生的变更操作。</p>

<h3>段合并</h3>

<p>每个分段都会消耗文件句柄、内存。每个搜索请求都需要轮流检查每个分段，查询完再对结果进行合并。</p>

<p>因此需要通过一定的策略将这些较小的分段合并为大的分段，常用的方案是选择大小相似的分段进行合并。在合并过程中，标记为删除的数据不会写入新分段，当合并过程结束，旧的分段数据被删除，标记删除的数据才会从磁盘删除。</p>

<hr />

<h2>集群内部原理</h2>

<h3>集群节点角色</h3>

<p><strong>主节点</strong>（Master node）</p>

<p>主节点负责集群层面的相关操作，管理集群变更。</p>

<p>通过配置node.master使节点具有被选举为master的资格，主节点全局唯一，从有资格的节点中进行选举。</p>

<p>主节点也可以作为数据节点，但尽可能做少量的工作，因此生产环境应尽量分离主节点和数据节点。</p>

<p>为了防止数据丢失，每个主节点应该知道有资格成为主节点的节点数量。</p>

<p><strong>数据节点</strong>（Data node）</p>

<p>负责保存数据、执行数据相关操作。</p>

<p>一般情况下，数据读写流程只和数据节点交互，不会和主节点交互。</p>

<p><strong>预处理节点</strong>（Ingest node）</p>

<p>5.0版本开始引入的概念，预处理操作允许在索引文档之前，也就是写入数据之前，通过实现定义好的一系列的processors和pipeline，对数据进行某种转换。processors和pipeline拦截bulk和index请求，在应用相关操作后将文档传回给index或bulk API。</p>

<p><strong>协调节点</strong>（Coordinating node）</p>

<p>客户端请求可以发送到集群的任何节点，每个节点都可以知道任意文档的位置；将请求转发给保存数据的数据节点，每个数据节点在本地执行操作，将结果返回给协调节点；协调节点收集数据，将每个数据节点的结果合并为单个全局结果并返回给客户端。</p>

<p>处理客户端请求的节点称为协调节点。</p>

<h3>集群健康状态</h3>

<p>从数据完整性的角度划分，集群健康状态分为三种：</p>

<ul>
	<li>Green：所有主分片和副本分片都正常运行</li>
	<li>Yellow：所有主分片都正常运行，但不是所有的副本分片都正常运行，可能存在单点故障风险</li>
	<li>Red：有主分片不正常</li>
</ul>

<p>每个索引也有上述三种状态，假设丢失了一个副本分片，该分片所属的索引和整个集群变为Yellow状态，其他索引仍为Green状态。</p>

<h3>集群状态</h3>

<p>集群状态元数据是全局信息，元数据包括路由信息、配置信息等，其中最重要的是内容路由信息，它描述了“哪个分片在哪个节点上”这种信息。</p>

<p>集群状态由主节点负责维护，如果主节点从数据节点接收更新，则将这些更新广播到集群的其他节点，让每个节点上的集群状态保持更新。2.0后更新的集群状态只发增量内容，并且是被压缩的。</p>

<h3>集群扩容</h3>

<p>当集群添加节点时，分片会均衡地分配到集群的各个节点，从而对索引和搜索过程进行负载均衡。</p>

<p>分片副本实现了数据冗余，从而防止硬件故障导致的数据丢失。</p>

<p>分片分配过程除了让节点间均匀存储，还要保证不把主分片和副本分片分配到同一节点，避免单个节点故障引起数据丢失。</p>

<p>当节点异常时，es会自动处理节点异常。当主节点异常时，集群会重新选举主节点，当主分片异常时，会将副本分片提升为主分片。</p>

<hr />

<h2>客户端API</h2>

<p>当需要实现一个客户端对集群进行读写操作时，可以选择REST接口、java REST API或者java API。</p>

<p>Java REST API是对原生REST接口的封装。REST接口、java REST API使用9200端口通信，采用JSON over HTTP方式；java API使用9300端口通信，数据序列化为二进制。</p>

<h3>主要内部模块简介</h3>

<p><strong>Cluster</strong></p>

<p>Cluster模块是主节点执行集群管理的封装实现，管理集群状态，维护集群层面的配置信息。主要功能：</p>

<ul>
	<li>管理集群状态，将新生成的集群状态发布到集群所有节点</li>
	<li>调用allocation模块执行分片分配，决策哪些分片应该分配到哪个节点</li>
	<li>在集群各节点中直接迁移分片，保持数据平衡</li>
</ul>

<p><strong>allocation</strong></p>

<p>封装了分片分配相关的功能和策略，包括主分片的分配和副本分片的分配，本模块由主节点调用。创建新索引、集群完全重启都需要分片分配的过程。</p>

<p><strong>discovery</strong></p>

<p>发现模块负责发现集群中的节点，以及选举主节点。</p>

<p><strong>gateway</strong></p>

<p>负责对收到master广播下来的集群状态数据的持久化存储，并在集群完全重启时恢复它们。</p>

<p><strong>indices</strong></p>

<p>管理全局级的索引设置，不包括索引级的。它还封装了索引数据恢复功能。集群启动阶段需要的主分片恢复和副分片恢复就是在这个模块实现的。</p>

<p><strong>HTTP</strong></p>

<p>允许通过JSON over HTTP的方式访问es的API，HTTP模块本质上是完全异步的，这意味着没有阻塞线程等待响应。</p>

<p><strong>Transport</strong></p>

<p>用于集群内节点之间的内部通信。从一个节点到另一个节点的每个请求都使用传输模快。</p>

<p>Transport本质上是完全异步的。传输模块使用TCP通信，每个节点都与其他节点维持若干TCP长连接。内部节点间的所有通信都是本模块承载的。</p>

<p><strong>Engine</strong></p>

<p>Engine模块封装了对Lucene的操作和translog的调用，它是对一个分片读写操作的最终提供者。</p>

<h3>模块结构</h3>

<p>Es使用Guice框架进行模块化管理。Guice是Google开发的轻量级依赖注入框架（ioc）。</p>

<p>软件设计中经常说要依赖于抽象而不是具象，ioc就是这种理念的实现方式，并且在内部实现了对象的创建和管理。</p>

<p>在Guice框架下，一个典型的模块由Service和Module类组成，Service实现业务功能，Module配置绑定信息。</p>

<h3>模块管理</h3>

<p>定义好的模块由ModulesBuilder类统一管理，ModulesBuilder是es对Guice的封装，内部调用Guice接口，主要对外提供两个方法：</p>

<ul>
	<li>add：添加创建好的模块</li>
	<li>createInjector：调用Guice.createInjector创建并返回Injector，后续通过Injector获取相应Service类的实例</li>
</ul>

<hr />

<h2>物理设计：节点和分片</h2>

<p>如果把一个索引分为5个分片，每个分片有一个副本。</p>

<figure><img src="/Users/xerxes/note/elasticsearch/src/%E7%B4%A2%E5%BC%95%E5%88%86%E7%89%87.jpg"/></figure>

<p>从技术上来说，一份分片是一个目录中的文件，Lucene用这些文件存储索引数据。分片也是es将数据从一个节点迁移到另一个节点的最小单位。</p>

<h3>创建拥有一个或多个节点的集群</h3>

<p><strong>一个节点是一个es的实例</strong>。在服务器上启动es之后，就有了一个节点。如果在另一台服务器上启动es，就是另一个节点。甚至可以在同一台服务器上启动多个es进程，就会拥有多个节点。</p>

<p><strong>多个节点可以加入同一个集群</strong>。在多节点集群上，同样的数据可以在多台服务器上传播。默认情况下可以连接集群中任一节点并访问完整的数据集。</p>

<h3>索引一篇文档</h3>

<p>接受索引请求的es节点首先选择文档索引到哪个分片。默认情况下，文档在分片中均匀分布。对于每个文档，分片是通过其ID字符串的hash决定的。每份分片拥有相同的hash范围，接收新文档的机会均等。</p>

<p>一旦目标分片确定，接收请求的节点将文档转发到该分片所在的节点。</p>

<p>随后，文档被发送到该主分片的所有副本分片进行索引，使副本分片和主分片之间保持数据的同步。在所有可用副本分片完成文档的索引后，索引命令就会成功返回。 </p>

<figure><img src="/Users/xerxes/note/elasticsearch/src/%E5%A6%82%E4%BD%95%E7%B4%A2%E5%BC%95.jpg"/></figure>

<h3>搜索索引</h3>

<p>当搜索一个索引时，es需要在该索引的完整分片集合中进行查找。这些分片可以是主分片，也可以是副本分片，因为对应的主分片和副本分片通常包含一样的文档。es在索引的主分片和副本分片中进行搜索请求的负载均衡，使得副本分片对于搜索性能和容错都有所帮助。</p>

<p>接收搜索请求的节点将请求转发到一组包含所有数据的分片。es使用round-robin的轮询机制选择可用的分片，将请求转发过去。然后从这些分片收集结果，将其聚集到单一的回复，返回给客户端。</p>

<figure><img src="/Users/xerxes/note/elasticsearch/src/%E6%90%9C%E7%B4%A2%E8%BF%87%E7%A8%8B.jpg"/></figure>

<p>默认情况下，搜索请求通过round-robin轮询机制选中主分片和副本分片，其假设集群中所有节点同样快。如果不是如此，可以组织数据或配置分片，防止较慢的节点称为瓶颈。</p>

<h3>主分片和副本分片</h3>

<blockquote>
<p>es索引是由一个或多个主分片和零个或多个副本分片构成的。</p>
</blockquote>

<p>一份分片是Lucene的索引，是一个包含倒排索引的文件。默认存储原始文档的内容，再加上一些额外的信息，如词条字典和词频。词条字典将每个词条和包含该词条的文档映射起来，搜索时根据这个字典快速识别匹配的文档。</p>

<p>副本分片是主分片的完整副本。副本分片用于搜索，或者是在原有主分片丢失后成为新的主分片。</p>

<p>副本分片可以在运行的时候进行添加和移除，而主分片的数量必须在创建索引之前就设置好。</p>

<h3>在集群中分发分片</h3>

<p>在集群中增加节点，使分片在所有的节点上进行负载均衡，以这种方式进行扩展称为<strong>水平扩展</strong>。为节点增加更多硬件资源称为<strong>垂直扩展</strong>。</p>

<hr />

<h2>索引新数据</h2>

<h3>通过curl索引一篇文档</h3>

<p>执行命令：</p>

<pre><code>curl -XPUT &#39;localhost:9200/get-togather/group/1?pretty&#39; -d &#39;{
    &quot;name&quot;: &quot;elasticsearch denver&quot;,
    &quot;organizer&quot;: &quot;True&quot;
}&#39; -H &quot;Content-Type: application/json&quot;
</code></pre>

<p>得到返回结果：</p>

<pre><code>{
  &quot;_index&quot; : &quot;get-togather&quot;,
  &quot;_type&quot; : &quot;group&quot;,
  &quot;_id&quot; : &quot;1&quot;,
  &quot;_version&quot; : 2,
  &quot;result&quot; : &quot;updated&quot;,
  &quot;_shards&quot; : {
    &quot;total&quot; : 2,
    &quot;successful&quot; : 1,
    &quot;failed&quot; : 0
  },
  &quot;_seq_no&quot; : 1,
  &quot;_primary_term&quot; : 9
}
</code></pre>

<p>结果中包含索引、类型和索引文档的ID。</p>

<h3>创建索引和映射类型</h3>

<h4>手动创建索引</h4>

<pre><code>curl -XPUT &#39;localhost:9200/new-index&#39; -H &quot;Contant-Type:application/json&quot;
</code></pre>

<p>创建索引本身比创建文档要花费更长时间，最好让索引事先准备就绪。</p>

<p>另外如果想指定和es不同的配置（如分片的数量）也需要提前创建索引。</p>

<h4>获取映射</h4>

<p>映射是随着新文档自动创建的，es会自动识别字段类型，将其添加到映射。</p>

<p>可以通过发送一个HTTP GET请求查看当前索引的映射：</p>

<pre><code>curl &#39;localhost:9200/get-togather/_mapping/group?pretty&#39;
</code></pre>

<h3>搜索并获取数据</h3>

<h4>在哪里搜索</h4>

<p>可以告诉es在特定的类型和特定的索引中进行查询，也可以在同一个索引的多个类型中搜索、在多个索引中搜索或是在所有的索引中搜索。</p>

<h4>回复的内容</h4>

<figure><img src="/Users/xerxes/note/elasticsearch/src/es%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9E%E5%86%85%E5%AE%B9%E8%A7%A3%E9%87%8A.jpg"/></figure>

<p>Es的JSON应答包含了所要求的信息，包括时间、分片、命中统计数据、文档等。</p>

</body>
</html>

